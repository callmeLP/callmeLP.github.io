<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>神经网络中的卷积与反卷积</title>
      <link href="/2023/04/20/nn-conv-deconv/"/>
      <url>/2023/04/20/nn-conv-deconv/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>普通图像反卷积，跟深度学习中的反卷积是一回事吗？别傻傻分不清！其实它们根本不是一个概念</p><h2 id="图像反卷积"><a href="#图像反卷积" class="headerlink" title="图像反卷积"></a>图像反卷积</h2><p>最早支持反卷积是因为图像去噪跟去模糊，知道图像去模糊时候会使用反卷积技术，那个是真正的反卷积计算，会估算核，会有很复杂的数学推导，主要用在图像的预处理与数字信号处理中。本质上反卷积是一种图像复原技术，典型的图像模糊可以看成事图像卷积操作得到的结果，把模糊图像重新复原为清晰图像的过程常常被称为去模糊技术，根据模糊的类别不同可以分为运动模糊与离焦模糊，OpenCV支持对这两张模糊图像进行反卷积处理得到清晰图像。反卷积的基本原理就是把图像转换到频率域，通过估算图像的核函数，在频率域对图像点乘计算之后，重新获取图像信息，转回为空间域。主要操作都在频率域，转换通过离散傅里叶（DFT）变换与反变换，通过维纳滤波处理获取反模糊信息，OpenCV支持反卷积采用维纳滤波方式的去模糊，但是参数调整事一个大坑，基本上每张图像的参数都不一样，很难有相同的结果。最近这些年，图像反模糊逐步被深度学习的方法引领，OpenCV提供的那几个函数越来越少的人知道，主要是通用性很差。</p><h2 id="深度学习中的反卷积"><a href="#深度学习中的反卷积" class="headerlink" title="深度学习中的反卷积"></a>深度学习中的反卷积</h2><p>深度学习中典型网络就是卷积神经网络，对图像分类，对象检测都可以取得很好的效果。但是在语义分割任务中，网络模型涉及到上采样操作，最常见的就是通过填充0或者最近邻插值的方式来完成上采样。在ICCV 2015年的一篇论文中提出了可学习的反卷积网络，不再通过简单粗暴的填充0或者最近邻插值方法来完成上采样，让整个过程变成可学习，在图像语义分割网络中实现了对上采样过程的训练。论文中提到的反卷积操作实现上采样跟图像处理中反卷积实现图像去模糊有本质区别，这里的反卷积更加准确的说法应该是转置卷积。</p><h1 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h1><p>图中第二行就是卷积与反卷积的示意图，下面通过一个简单的例子来解释上图的内容。假设有4x4大小的二维矩阵D，有3x3大小的卷积核C，如下：     </p><table><thead><tr><th>3</th><th>3</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>3</td></tr><tr><td>3</td><td>1</td><td>2</td><td>2</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><table><thead><tr><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>0</td></tr><tr><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>直接对上述完成卷积操作（不考虑边缘填充）输出卷积结果是2x2的矩阵</p><table><thead><tr><th>12</th><th>12</th></tr></thead><tbody><tr><td>10</td><td>17</td></tr></tbody></table><p>其中2x2卷积的输出结果来自D中第二行第二列像素位置对应输出，相关的卷积核与数据点乘的计算为：</p><p>0x3+1x3+2x2+2x0+2x0+0x1+0x3+1x1+2x2&#x3D;12，可以看出卷积操作是卷积核在矩阵上对应位置点乘线性组合得到的输出，对D&#x3D;4x4大小的矩阵从左到右，从上到下，展开得到16个维度的向量表示如下：<br>$$<br>D^{T} &#x3D; [3\ 3\ 2\ 1\ 0\ 0\ 1\ 3\ 3\ 1\ 2\ 2\ 2\ 0\ 0\ 2]<br>$$<br>我们同样可以把3x3的卷积核表示如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230419155414.png" alt="20230419155414"><br>为了获得卷积核的4x4的向量表示，我们可以对其余部分填充零，那么卷积核在D上面移动的位置与对应的一维向量表示如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230419155433.png" alt="20230419155433"><br>考虑到卷积核C与D的点成关系，合并在一起还可以写成如下形式：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230419155447.png" alt="20230419155447"><br>把上面卷积核中的字符表示替换为实际卷积核C，得到：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230419155500.png" alt="20230419155500"><br>所以上述的卷积操作可以简单的写为：<br>$$<br>D^{T}C &#x3D; [12\ 12\ 10\ 17]<br>$$<br>重排以后就得到上面的2x2的输出结果。</p><h1 id="反卷积操作"><a href="#反卷积操作" class="headerlink" title="反卷积操作"></a>反卷积操作</h1><p>现在我们有2x2的数据块，需要通过卷积操作完成上采样得到4x4的数据矩阵，怎么完成这样的操作，很容易，我们把2x2转换为1x4的向量E，然后对卷积核C转置，再相乘，表示为$EC^{T}$就得到16维度向量，重排以后就得到了4x4的数据块。这个就是深度学习中的卷积与反卷积最通俗易懂的解释。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 输入一维数据</span></span><br><span class="line">d = torch.tensor([<span class="number">1.</span>,<span class="number">2.</span>])</span><br><span class="line"><span class="comment"># 一维卷积核</span></span><br><span class="line">f = torch.tensor([<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br><span class="line"><span class="comment"># 维度转换dd</span></span><br><span class="line">d = d.view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f = f.view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 一维转置卷积</span></span><br><span class="line">ct1d = torch.nn.ConvTranspose1d(in_channels=<span class="number">1</span>, out_channels=<span class="number">1</span>, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, bias=<span class="number">0</span>)</span><br><span class="line">ct1d.weight = torch.nn.Parameter(f);</span><br><span class="line"><span class="comment"># 打印输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入数据:&quot;</span>, d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出上采样结果:&quot;</span>, ct1d(d))</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_42722197/article/details/125076341">https://blog.csdn.net/qq_42722197/article/details/125076341</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>知识蒸馏简介</title>
      <link href="/2023/04/20/nn-knowledgeDistillation/"/>
      <url>/2023/04/20/nn-knowledgeDistillation/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在化学中，蒸馏是一种有效的分离不同沸点组分的方法，大致步骤是先升温使低沸点的组分汽化，然后降温冷凝，达到分离出目标物质的目的。化学蒸馏条件:<br>（1）蒸馏的液体是混合物;<br>（2）各组分沸点不同。</p><p>一般地，大模型往往是单个复杂网络或者是若干网络的集合，拥有良好的性能和泛化能力，而小模型因为网络规模较小，表达能力有限。因此，可以利用大模型学习到的知识去指导小模型训练，使得小模型具有与大模型相当的性能，但是参数数量大幅降低，从而实现模型压缩与加速，这就是知识蒸馏与迁移学习在模型优化中的应用。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418201141.png" alt="20230418201141"><br>Hinton等人最早在文章《Distilling the Knowledge in a Neural Network》中提出了知识蒸馏这个概念，其核心思想是先训练一个复杂网络模型，然后使用这个复杂网络的输出和数据的真实标签去训练一个更小的网络，因此知识蒸馏框架通常包含了一个复杂模型(被称为Teacher模型)和一个小模型(被称为Student模型)。</p><h2 id="知识蒸馏的作用"><a href="#知识蒸馏的作用" class="headerlink" title="知识蒸馏的作用"></a>知识蒸馏的作用</h2><p>深度学习在计算机视觉、语音识别、自然语言处理等内的众多领域中均取得了令人难以置信的性能。但是，大多数模型在计算上过于昂贵，无法在移动端或嵌入式设备上运行。因此需要对模型进行压缩，且知识蒸馏是模型压缩中重要的技术之一。</p><h3 id="提升模型精度"><a href="#提升模型精度" class="headerlink" title="提升模型精度"></a>提升模型精度</h3><p>如果对目前的网络模型A的精度不是很满意，那么可以先训练一个更高精度的teacher模型B（通常参数量更多，时延更大），然后用这个训练好的teacher模型B对student模型A进行知识蒸馏，得到一个更高精度的A模型。  </p><h3 id="降低模型时延，压缩网络参数"><a href="#降低模型时延，压缩网络参数" class="headerlink" title="降低模型时延，压缩网络参数"></a>降低模型时延，压缩网络参数</h3><p>如果对目前的网络模型A的时延不满意，可以先找到一个时延更低，参数量更小的模型B，通常来讲，这种模型精度也会比较低，然后通过训练一个更高精度的teacher模型C来对这个参数量小的模型B进行知识蒸馏，使得该模型B的精度接近最原始的模型A，从而达到降低时延的目的。     </p><h3 id="标签之间的域迁移"><a href="#标签之间的域迁移" class="headerlink" title="标签之间的域迁移"></a>标签之间的域迁移</h3><p>假如使用狗和猫的数据集训练了一个teacher模型A，使用香蕉和苹果训练了一个teacher模型B，那么就可以用这两个模型同时蒸馏出一个可以识别狗、猫、香蕉以及苹果的模型，将两个不同域的数据集进行集成和迁移。</p><blockquote><h3 id="模型压缩知识补充"><a href="#模型压缩知识补充" class="headerlink" title="模型压缩知识补充"></a>模型压缩知识补充</h3><ul><li>模型剪枝：即移除对结果作用较小的组件，如减少 head 的数量和去除作用较少的层，共享参数等，ALBERT属于这种；    </li><li>量化：比如将 float32 降到 float8；    </li><li>知识蒸馏：将 teacher 的能力蒸馏到 student上，一般 student 会比 teacher 小。我们可以把一个大而深的网络蒸馏到一个小的网络，也可以把集成的网络蒸馏到一个小的网络上。    </li><li>参数共享：通过共享参数，达到减少网络参数的目的，如 ALBERT 共享了 Transformer 层；    </li><li>参数矩阵近似：通过矩阵的低秩分解或其他方法达到降低矩阵参数的目的；</li></ul></blockquote><h3 id="知识蒸馏与从头开始训练模型有什么不同？"><a href="#知识蒸馏与从头开始训练模型有什么不同？" class="headerlink" title="知识蒸馏与从头开始训练模型有什么不同？"></a>知识蒸馏与从头开始训练模型有什么不同？</h3><p>显然，对于更复杂的模型，理论搜索空间要大于较小网络的搜索空间。但是，如果我们假设使用较小的网络可以实现相同（甚至相似）的收敛，则教师网络的收敛空间应与学生网络的解空间重叠。</p><p>不幸的是，仅此一项并不能保证学生网络在同一位置收敛。学生网络的收敛可能与教师网络的收敛大不相同。但是，如果指导学生网络复制教师网络的行为（教师网络已经在更大的解空间中进行了搜索），则可以预期其收敛空间与原始教师网络收敛空间重叠。      </p><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418201935.png" alt="20230418201935">         </p><h1 id="知识蒸馏的方法"><a href="#知识蒸馏的方法" class="headerlink" title="知识蒸馏的方法"></a>知识蒸馏的方法</h1><p>知识蒸馏是对模型的能力进行迁移，根据迁移的方法不同可以简单分为<strong>基于目标蒸馏</strong>（也称为Soft-target蒸馏或Logits方法蒸馏）和<strong>基于特征蒸馏</strong>的算法两个大的方向，下面我们对其进行介绍。</p><h2 id="目标蒸馏-Logits方法"><a href="#目标蒸馏-Logits方法" class="headerlink" title="目标蒸馏-Logits方法"></a>目标蒸馏-Logits方法</h2><p>目标蒸馏方法中最经典的论文就是来自于2015年Hinton发表的一篇神作《<a href="https://arxiv.org/pdf/1503.02531.pdf">Distilling the Knowledge in a Neural Network</a>》。下面我们以这篇神作为例，给大家讲讲目标蒸馏方法的原理。</p><p>在这篇论文中，Hinton将问题限定在分类问题下，分类问题的共同点是模型最后会有一个softmax层，其输出值对应了相应类别的概率值。在知识蒸馏时，由于我们已经有了一个泛化能力较强的Teacher模型，我们在利用Teacher模型来蒸馏训练Student模型时，可以直接让Student模型去学习Teacher模型的泛化能力。一个很直白且高效的迁移泛化能力的方法就是：使用softmax层输出的类别的概率来作为“Soft-target” 。</p><h3 id="Hard-target-和-Soft-target"><a href="#Hard-target-和-Soft-target" class="headerlink" title="Hard-target 和 Soft-target"></a>Hard-target 和 Soft-target</h3><p>传统的神经网络训练方法是定义一个损失函数，目标是使预测值尽可能接近于真实值（Hard- target），损失函数就是使神经网络的损失值和尽可能小。这种训练过程是对ground truth求极大似然。在知识蒸馏中，是使用大模型的类别概率作为Soft-target的训练过程。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418202454.png" alt="20230418202454">   </p><ul><li>Hard-target：原始数据集标注的 one-shot 标签，除了正标签为 1，其他负标签都是 0。</li><li>Soft-target：Teacher模型softmax层输出的类别概率，每个类别都分配了概率，正标签的概率最高。</li></ul><p>知识蒸馏用Teacher模型预测的 Soft-target 来辅助 Hard-target 训练 Student模型的方式为什么有效呢？softmax层的输出，除了正例之外，负标签也带有Teacher模型归纳推理的大量信息，比如某些负标签对应的概率远远大于其他负标签，则代表 Teacher模型在推理时认为该样本与该负标签有一定的相似性。而在传统的训练过程(Hard-target)中，所有负标签都被统一对待。也就是说，知识蒸馏的训练方式使得每个样本给Student模型带来的信息量大于传统的训练方式。</p><p>如在MNIST数据集中做手写体数字识别任务，假设某个输入的“2”更加形似”3”，softmax的输出值中”3”对应的概率会比其他负标签类别高；而另一个”2”更加形似”7”，则这个样本分配给”7”对应的概率会比其他负标签类别高。这两个”2”对应的Hard-target的值是相同的，但是它们的Soft-target却是不同的，由此我们可见Soft-target蕴含着比Hard-target更多的信息。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418202721.png" alt="20230418202721"><br>在使用 Soft-target 训练时，Student模型可以很快学习到 Teacher模型的推理过程；而传统的 Hard-target 的训练方式，所有的负标签都会被平等对待。因此，Soft-target 给 Student模型带来的信息量要大于 Hard-target，并且Soft-target分布的熵相对高时，其Soft-target蕴含的知识就更丰富。同时，使用 Soft-target 训练时，梯度的方差会更小，训练时可以使用更大的学习率，所需要的样本也更少。这也解释了为什么通过蒸馏的方法训练出的Student模型相比使用完全相同的模型结构和训练数据只使用Hard-target的训练方法得到的模型，拥有更好的泛化能力。</p><h3 id="目标蒸馏的具体方法"><a href="#目标蒸馏的具体方法" class="headerlink" title="目标蒸馏的具体方法"></a>目标蒸馏的具体方法</h3><p>在介绍知识蒸馏方法之前，首先得明白什么是Logits。我们知道，对于一般的分类问题，比如图片分类，输入一张图片后，经过DNN网络各种非线性变换，在网络最后Softmax层之前，会得到这张图片属于各个类别的大小数值$z_{i}$，某个类别的$z_{i}$数值越大，则模型认为输入图片属于这个类别的可能性就越大。<br>什么是Logits? 这些汇总了网络内部各种信息后，得出的属于各个类别的汇总分值$z_{i}$，就是Logits，i代表第i个类别，$z_{i}$代表属于第i类的可能性。因为Logits并非概率值，所以一般在Logits数值上会用Softmax函数进行变换，得出的概率值作为最终分类结果概率。<u>Softmax一方面把Logits数值在各类别之间进行概率归一</u>，使得各个类别归属数值满足概率分布；<u>另外一方面，它会放大Logits数值之间的差异，使得Logits得分两极分化</u>，Logits得分高的得到的概率值更偏大一些，而较低的Logits数值，得到的概率值则更小。</p><p>神经网络使用 softmax 层来实现 logits 向 probabilities 的转换。原始的softmax函数：<br>$$<br>q_{i}&#x3D; \frac{\exp{(z_{i})}}{\sum_{j}{\exp{(z_{i})}}}<br>$$<br>但是直接使用softmax层的输出值作为soft target，这又会带来一个问题: 当softmax输出的概率分布熵相对较小时，负标签的值都很接近0，对损失函数的贡献非常小，小到可以忽略不计。因此”温度”这个变量就派上了用场。下面的公式是加了温度这个变量之后的softmax函数:<br>$$<br>q_{i}&#x3D; \frac{\exp{(z_{i}&#x2F;T)}}{\sum_{j}{\exp{(z_{i}&#x2F;T)}}}<br>$$<br>其中$q_{i}$是每个类别输出的概率，$z_{i}$是每个类别输出的 logits，$T$就是温度。当温度$T &#x3D; 1$时，这就是标准的 Softmax 公式。$T$越高，softmax的output probability distribution越趋于平滑，其分布的熵越大，负标签携带的信息会被相对地放大，模型训练将更加关注负标签。</p><p>知识蒸馏训练的具体方法如下图所示，主要包括以下几个步骤：   </p><ol><li>训练好Teacher模型；</li><li>利用高温 $T_{high}$ 产生 Soft-target；</li><li>使用 ${Soft-taget, T_{high}}$ 和 ${Hard - target, T &#x3D; 1}$ 同时训练 Student模型；</li><li>设置温度 $T &#x3D; 1$，Student模型线上做inference。</li></ol><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418204335.png" alt="20230418204335"><br>训练Teacher的过程很简单，我们把第2步和第3步过程统一称为：高温蒸馏的过程。高温蒸馏过程的目标函数由distill loss(对应Soft-target)和Student loss(对应Hard-target)加权得到。如下所示：<br>$$<br>L &#x3D; \alpha L_{soft}+\beta L_{hard}<br>$$    </p>> (1) Teacher模型和Student模型同时输入 transfer set (这里可以直接复用训练Teacher模型用到的training set)，用Teacher模型在高温 $T_{high}$ 下产生的softmax distribution来作为Soft-target，Student模型在相同温度 $T_{high}$ 条件下的softmax输出和Soft-target的cross entropy就是Loss函数的第一部分 $L_{soft}$，具体形式如下所示：> $$> L_{soft} = -\sum^{N}_{i}p^{T}_{i}\log{(q^{T}_{i})}> $$> 其中，$p^{T}_{i}$ 指Teacher模型在温度等于T的条件下softmax输出在第 $i$ 类上的值。$q^{T}_{i}$ 指Student的在温度等于 $T$ 的条件下softmax输出在第 $i$ 类上的值。公式如下：> $$> p^{T}_{i} = \frac{\exp{(v_{i}/T)}}{\sum^{N}_{k}\exp{(v_{k}/T)}}> $$> $$> q^{T}_{i} = \frac{\exp{(z_{i}/T)}}{\sum^{N}_{k}\exp{(z_{k}/T)}}> $$> 其中，$v_{i}$ 指Teacher模型的logits，$z_{i}$ 指Student模型的logits， $N$ 指总标签数量。  > (2) Student模型在T=1的条件下的softmax输出和ground truth的cross entropy就是Loss函数的第二部分 $L_{hard}$ 。> $$> L_{hard} = - \sum^{N}_{i}c_{i}\log{(q^{1}_{i})}> $$> 其中， $c_{i}$ 指在第 $i$ 类上的ground truth值,$c_{i} \in{\{0,1\}}$, 正标签取1，负标签取0。$q^{1}_{i}$ 形式如下：> $$>  q^{1}_{i} = \frac{\exp{(z_{i})}}{\sum^{N}_{k}{\exp{z_{k}}}}> $$> 第二部分Loss $L_{hard}$ 的必要性其实很好理解：Teacher模型也有一定的错误率，使用ground truth可以有效降低错误被传播给Student模型的可能性。打个比喻，老师虽然学识远远超过学生，但是他仍然有出错的可能，而这时候如果学生在老师的教授之外，可以同时参考到标准答案，就可以有效地降低被老师偶尔的错误“带偏”的可能性。    <p>最后，$\alpha$ 和 $\beta$ 是关于 $L_{soft}$ 和 $L_{hard}$ 的权重，实验发现，当 $L_{hard}$ 权重较小时，能产生最好的效果，这是一个经验性的结论。文章《【经典简读】知识蒸馏(Knowledge Distillation) 经典之作》，地址：<a href="https://zhuanlan.zhihu.com/p/102038521">https://zhuanlan.zhihu.com/p/102038521</a> 和 文章《【Knowledge Distillation】知识蒸馏学习》，地址：<a href="https://baihaoran.xyz/2020/05/04/Knowledge-Distillation.html">https://baihaoran.xyz/2020/05/04/Knowledge-Distillation.html</a> 都进行了理论的推导，这里我直接给出结论：由于 $L_{soft}$ 贡献的梯度大约为 $L_{hard}$ 的 $\frac{1}{T^{2}}$，因此在同时使用Soft-target和Hard-target的时候，需要在 $L_{soft}$ 的权重上乘以 $T^{2}$ 的系数，这样才能保证Soft-target和Hard-target贡献的梯度量基本一致。</p><h3 id="蒸馏的一种特殊形式：-直接Matching-Logits"><a href="#蒸馏的一种特殊形式：-直接Matching-Logits" class="headerlink" title="蒸馏的一种特殊形式： 直接Matching Logits"></a>蒸馏的一种特殊形式： 直接Matching Logits</h3><p>直接Matching Logits指的是，直接使用softmax层的输入logits（而不再是输出）作为Soft- target，需要最小化的目标函数是Teacher模型和Student模型的logits之间的平方差，推导不详细解释。经过Softmax的蒸馏方式和直接Matching Logits的方式，当温度 $T \rightarrow \infty$ 时Soft-target损失函数部分是等价的，即Matching Logits是一般知识蒸馏方法的一种特殊形式。</p><h3 id="关于温度"><a href="#关于温度" class="headerlink" title="关于温度"></a>关于温度</h3><p>这里消除关于温度的伏笔。在知识蒸馏中，需要使用高温将知识“蒸馏”出来，但是如何调节温度 $T$ 呢，温度的变化会产生怎样的影响呢？<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418211846.png" alt="20230418211846"><br>温度 $T$ 有这样几个特点：</p><ul><li>原始的softmax函数是 $T &#x3D; 1$ 时的特例；$T&lt;1$ 时，概率分布比原始更“陡峭”，也就是说，当 $T \rightarrow 0$ 时，Softmax 的输出值会接近于 Hard-target；$T&gt;1$时，概率分布比原始更“平缓”。</li><li>随着 $T$ 的增加，Softmax 的输出分布越来越平缓，信息熵会越来越大。温度越高，softmax上各个值的分布就越平均，思考极端情况，当 $T$ ，此时softmax的值是平均分布的。</li><li>不管温度 $T$ 怎么取值，Soft-target都有忽略相对较小的 $p_{i}$ （Teacher模型在温度为T时softmax输出在第 $i$ 类上的值）携带的信息的倾向。</li></ul><p>温度的高低改变的是Student模型训练过程中对负标签的关注程度。当温度较低时，对负标签的关注，尤其是那些显著低于平均值的负标签的关注较少；而温度较高时，负标签相关的值会相对增大，Student模型会相对更多地关注到负标签。</p><p>实际上，负标签中包含一定的信息，尤其是那些负标签概率值显著高于平均值的负标签。但由于Teacher模型的训练过程决定了负标签部分概率值都比较小，并且负标签的值越低，其信息就越不可靠。因此温度的选取需要进行实际实验的比较，本质上就是在下面两种情况之中取舍:    </p><ul><li>当想从负标签中学到一些信息量的时候，温度 $T$ 应调高一些；</li><li>当想减少负标签的干扰的时候，温度 $T$ 应调低一些；</li></ul><p>总的来说，$T$ 的选择和Student模型的大小有关，Student模型参数量比较小的时候，相对比较低的温度就可以了。因为参数量小的模型不能学到所有Teacher模型的知识，所以可以适当忽略掉一些负标签的信息。</p><p>最后，在整个知识蒸馏过程中，<u>我们先让温度 $T$ 升高，然后在测试阶段恢复“低温“（ $T &#x3D; 1$ ），从而将原模型中的知识提取出来，因此将其称为是蒸馏</u>，实在是妙啊。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>待补充。。。。。</p><h2 id="特征蒸馏"><a href="#特征蒸馏" class="headerlink" title="特征蒸馏"></a>特征蒸馏</h2><p>另外一种知识蒸馏思路是特征蒸馏方法，如下图所示。它不像Logits方法那样，Student只学习Teacher的Logits这种结果知识，而是学习Teacher网络结构中的中间层特征。最早采用这种模式的工作来自于论文《FITNETS：Hints for Thin Deep Nets》，它强迫Student某些中间层的网络响应，要去逼近Teacher对应的中间层的网络响应。这种情况下，Teacher中间特征层的响应，就是传递给Student的知识。在此之后，出了各种新方法，但是大致思路还是这个思路，本质是Teacher将特征级知识迁移给Student。因此，接下来我们以这篇论文为主，详细介绍特征蒸馏方法的原理。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418212538.png" alt="20230418212538"></p><h3 id="主要解决的问题"><a href="#主要解决的问题" class="headerlink" title="主要解决的问题"></a>主要解决的问题</h3><p>这篇论文首先提出一个案例，既宽又深的模型通常需要大量的乘法运算，从而导致对内存和计算的高需求。因此，即使网络在准确性方面是性能最高的模型，其在现实世界中的应用也受到限制。</p><p>为了解决这类问题，我们需要通过模型压缩（也称为知识蒸馏）将知识从复杂的模型转移到参数较少的简单模型。</p><p>到目前为止，知识蒸馏技术已经考虑了Student网络与Teacher网络有相同或更小的参数。这里有一个洞察点是，深度是特征学习的基本层面，到目前为止尚未考虑到Student网络的深度。一个具有比Teacher网络更多的层但每层具有较少神经元数量的Student网络称为“thin deep network”。</p><p>因此，该篇论文主要针对Hinton提出的知识蒸馏法进行扩展，允许Student网络可以比Teacher网络更深更窄，使用teacher网络的输出和中间层的特征作为提示，改进训练过程和student网络的性能。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><ul><li>Student网络不仅仅拟合Teacher网络的Soft-target，而且拟合隐藏层的输出（Teacher网络抽取的特征）；</li><li>第一阶段让Student网络去学习Teacher网络的隐藏层输出（特征蒸馏）；</li><li>第二阶段使用Soft-target来训练Student网络（目标蒸馏）。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230418212819.png" alt="20230418212819"><br>把“宽”且“深”的网络蒸馏成“瘦”且“更深”的网络，需要进行两阶段的训练：<br><strong>第一阶段</strong>：首先选择待蒸馏的中间层（即Teacher的Hint layer和Student的Guided layer），如图中绿框和红框所示。由于两者的输出尺寸可能不同，因此，在Guided layer后另外接一层（上采样）卷积层，使得输出尺寸与Teacher的Hint layer匹配。接着通过知识蒸馏的方式训练Student网络的Guided layer，使得Student网络的中间层学习到Teacher的Hint layer的输出.</li></ul><p>就是根据Teacher模型的损失来指导预训练Student模型。记Teacher网络的前 $h$ 层作为 $W_{Hint}$ ，意为指导的意思。Student网络的前 $g$ 层作为 $W_{Guided}$，即被指导的意思，在训练之初Student网络进行随机初始化。需要学习一个映射函数 $W_{r}$ 使得 $W_{Guided}$ 的维度匹配 $W_{Hint}$ ，得到Student模型在下一阶段的参数初始化值，并最小化两者网络输出的MSE差异作为损失（特征蒸馏），如下：<br>$$<br>L_{HT}(W_{Guided},W_{r}) &#x3D; \frac{1}{2}||u_{h}(x, W_{Hint})-r(v_{g}(x;W_{Guided});W_{r})||^{2}<br>$$<br>其中，$W_{Hint}$  是教师网络的部分层的参数（绿框）；$W_{Guided}$ 是学生网络的部分层的参数（红框）；$W_{r}$ 是一个全连接层，用于将两个网络输出的size配齐，因为学生网络隐藏层宽度比教师网络窄。</p><p>第二阶段： 在训练好Guided layer之后，将当前的参数作为网络的初始参数，利用知识蒸馏的方式训练Student网络的所有层参数，使Student学习Teacher的输出。由于Teacher对于简单任务的预测非常准确，在分类任务中近乎one-hot输出，因此为了弱化预测输出，使所含信息更加丰富，作者使用Hinton等人论文《Distilling knowledge in a neural network》中提出的softmax改造方法，即在softmax前引入 $\tau$ 缩放因子，将Teacher和Student的pre-softmax输出均除以 $\tau$ 。也就是上面我们讲的加了温度的softmax。此时的损失函数为：<br>$$<br>L_{KD}(W_{S}) &#x3D; H(y_{true}, P_{s}) + \lambda H(P^{\tau}<em>{T},P^{\tau}</em>{S})<br>$$<br>其中， $H$ 指交叉熵损失函数；$\lambda$ 是一个可调整参数，以平衡两个交叉熵；第一部分为Student的输出与Ground-truth的交叉熵损失；第二部分为Student与Teacher的softmax输出的交叉熵损失。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>待补充。。。。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/nature553863/article/details/80568658">https://blog.csdn.net/nature553863/article/details/80568658</a><br><a href="https://baijiahao.baidu.com/s?id=1673896462976965754&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1673896462976965754&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之super_slomo</title>
      <link href="/2023/04/20/VFI-superslomo/"/>
      <url>/2023/04/20/VFI-superslomo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>论文地址：<a href="https://ieeexplore.ieee.org/document/8579036">Super SloMo: High Quality Estimation of Multiple Intermediate Frames for Video Interpolation</a><br>GitHub：<a href="https://github.com/avinashpaliwal/Super-SloMo">https://github.com/avinashpaliwal/Super-SloMo</a></p><h1 id="super-slomo"><a href="#super-slomo" class="headerlink" title="super_slomo"></a>super_slomo</h1><p>基于光流反向变换的框架,整体的结构如图所示：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230420155215.png" alt="20230420155215"><br>首先橙色部分使用Unet网络输入$I_{0},I_{1}$,输出$F_{0 \rightarrow 1}, F_{1 \rightarrow 0}$的双向光流。第二个网络也是Unet，但是输入部分和网络输出后需要经过计算得出最后的$I_{t}$。我们着重讲一下第二个网络。</p><h2 id="输入部分公式"><a href="#输入部分公式" class="headerlink" title="输入部分公式"></a>输入部分公式</h2><p>super_slomo通过第一个橙色网络输出了双向光流$F_{0 \rightarrow 1}, F_{1 \rightarrow 0}$，那么中间流$F_{t \rightarrow 0},F_{t \rightarrow 1}$如何计算呢？<br>我们可以近似为以下公式：<br>$$<br>F_{t \rightarrow 0} &#x3D; -(1-t)tF_{0 \rightarrow 1}+t^{2}F_{1 \rightarrow 0}<br>$$<br>$$<br>F_{t \rightarrow 0} &#x3D; (1-t)^{2}F_{0 \rightarrow 1}-t(1-t)F_{1 \rightarrow 0}<br>$$<br>其中，$t$代表的是需要插值的中间时刻。</p><h2 id="输出部分计算"><a href="#输出部分计算" class="headerlink" title="输出部分计算"></a>输出部分计算</h2><p>$$<br>I_{t} &#x3D; \alpha_{0} \odot g(I_{0},F_{t \rightarrow 0})+(1- \alpha_{0})\odot g(I_{1},F_{t \rightarrow 1})<br>$$<br>其中，$g(\ ,\ )$表示向后warping函数，可以使用双线性插值实现。$\alpha_{0}$控制两张输入图片的贡献。为了解决遮挡问题，论文中提出了可见图的概念$V_{t \leftarrow 0}$和$V_{t \leftarrow 1}$。$V_{t \leftarrow 0}(p) \in [0,1]$表示当从T &#x3D; 0移动到T &#x3D; t时，像素p是否保持可见（0被完全遮挡）。由此，我们可以得出新的公式：<br>$$<br>I_{t} &#x3D; \frac{1}{Z} \odot ((1-t)V_{t \leftarrow 0}\odot g(I_{0},F_{t \rightarrow 0})+tV_{t \leftarrow 1}\odot g(I_{1},F_{t \rightarrow 1}))<br>$$<br>其中$Z &#x3D; (1-t)V_{t \rightarrow 0} + tV_{t \rightarrow 1}$为归一化因子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之DVF中的体素流与三线性插值</title>
      <link href="/2023/04/18/VFI-DVF-vocelAndInsert/"/>
      <url>/2023/04/18/VFI-DVF-vocelAndInsert/</url>
      
        <content type="html"><![CDATA[<h1 id="体素（Voxel）"><a href="#体素（Voxel）" class="headerlink" title="体素（Voxel）"></a>体素（Voxel）</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411194508.png" alt="20230411194508"><br>题图中是3D数据的不同表示类型:<br>(a) 点云（Point clouds）:点云是三维空间(xyz坐标)点的集合<br>(b) 体素网格(Voxel grids):体素是3D空间的像素。量化的，大小固定的点云。每个单元都是固定大小和离散坐标(相当于图片的像素化风格应用到三维上，像无数个正方体积木组成的三维形状)<br>(c) 多边形网格(Polygon meshes)：mesh是面片的集合<br>(d) 多视图表示(Multi-view representations)：多视图表示是从不同模拟视点渲染的2D图像集合   </p><p>为了解释体素网格(Voxel grid),首先我们要了解占据栅格地图（Occupancy Grid Map）<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411195026.png" alt="20230411195026"><br>画一个二维网格，每个网格单元里有实体的话就为占据状态（1），空的话就为（0）。很好理解。</p><p>而体素就是固定分辨率的三维栅格地图。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411195043.png" alt="20230411195043"><br>体素网格是固定分辨率的，与之对应可变分辨率的网格叫八叉树地图(Octomap)。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411195137.png" alt="20230411195137"></p><h1 id="三线性插值"><a href="#三线性插值" class="headerlink" title="三线性插值"></a>三线性插值</h1><p>为了便于理解，介绍三线性插值之前先介绍一下线性插值和双线性插值</p><h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><p>已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值（反过来也是一样）：<br>$$<br>y &#x3D; \frac{x_{1}-x}{x_{1}-x_{0}}y_{0}+\frac{x-x_{0}}{x_{1}-x_{0}}y_{1}<br>$$<br>上式用x和x0，x1的距离作为一个权重，用于y0和y1的加权。双线性插值本质上就是在两个方向上做线性插值。</p><h2 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h2><p>在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411195941.png" alt="20230411195941"><br>假如我们想得到未知函数 f 在点 P &#x3D; (x, y) 的值，假设我们已知函数 f 在 Q11 &#x3D; (x1, y1)、Q12 &#x3D; (x1, y2), Q21 &#x3D; (x2, y1) 以及 Q22 &#x3D; (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200145.png" alt="20230411200145"><br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200129.png" alt="20230411200129"><br>然后在 y 方向进行线性插值，得到<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200341.png" alt="20230411200341"><br>综合起来就是双线性插值最后的结果：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200252.png" alt="20230411200252"></p><h2 id="三线性插值-1"><a href="#三线性插值-1" class="headerlink" title="三线性插值"></a>三线性插值</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200536.png" alt="20230411200536"><br>x0表示在x下方一个方格点，x1表示在x上方的一个方格点，对于y0、y1、z0、z1是同样的意思。<br>xd、yd、zd表示x、y、z在较小相关坐标的差值<br>第一步：沿着x轴方向插值    </p><blockquote><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200630.png" alt="20230411200630"><br>V[x0,y0,z0]表示该函数在（ x0,y0,z0)上的值  </p></blockquote><p>第二步：沿着y轴方向插值    </p><blockquote><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200815.png" alt="20230411200815"></p></blockquote><p>第三步：沿着z轴方向插值</p><blockquote><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411200847.png" alt="20230411200847"></p></blockquote><p>如此我们就得到了一个点的值。三线性插值的结果与沿三个轴的插值步骤的顺序无关：任何其他顺序，例如沿x，然后沿y，最后沿z，产生相同的值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/xbinworld/article/details/65660665">https://blog.csdn.net/xbinworld/article/details/65660665</a><br>基于深度体素流的模糊视频插帧方法<br>Video Frame Synthesis using Deep Voxel Flow</p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之前后向变形</title>
      <link href="/2023/04/18/VFI-foreward-backward-warping/"/>
      <url>/2023/04/18/VFI-foreward-backward-warping/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RIFE中使用了图像的后向变形技术，这里解释一下什么是前向变形和后向变形。</p><p>假设原图像为f(u,v)，扭曲的目标图像是g(x,y)</p><h1 id="foreward-warping"><a href="#foreward-warping" class="headerlink" title="foreward warping"></a>foreward warping</h1><p>在已知图像坐标转换关系x(u,v)和y(u,v)，直接把原图坐标映射到转换后图像相对应的位置上，近似取整得到结果。经过变换后，像素的位置可能落在非整数的位置，四舍五入（就近原则）选取坐落的终点，可能会有多个点四舍五入到同一个像素点，造成重叠效应；或者变换后的图像位置中没有投影过来的点，产生空洞。</p><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412161726.png" alt="20230412161726"><br>带来的问题：新图上有很多点并不规整</p><h1 id="backward-warping-x2F-Inverse-Warping"><a href="#backward-warping-x2F-Inverse-Warping" class="headerlink" title="backward warping&#x2F;Inverse Warping"></a>backward warping&#x2F;Inverse Warping</h1><p>对于每个获得新坐标(x,y)，用逆向映射函数u(x,y)，v(x,y)找到它在原图上对应的位置(u,v)，然后g(x,y)&#x3D;f(u,v)。若点算出来不在格子上，用插值方法获得像素值，因此不会产生的Forward Warping的问题。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412161935.png" alt="20230412161935"><br>——– 这个地方还是不太懂 需要看backward warping&#x2F;Inverse Warping相关论文</p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之光流</title>
      <link href="/2023/04/18/VFI-optical-flow/"/>
      <url>/2023/04/18/VFI-optical-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="光流场定义"><a href="#光流场定义" class="headerlink" title="光流场定义"></a>光流场定义</h1><p>场景中景物的运动会导致运动期间所获得的图像中景物处在不同的相对位置，这种位置的差别可以称之为视差，它对应景物运动反应在图像上的位移矢量。如果用视差除以时差，就得到速度矢量。一幅图像所有速度矢量构成一个矢量场，在很多情况下也可称为光流场   </p><p>利用图像差可以获得运动轨迹，利用光流不能获得运动轨迹，但可以获得对图像有用的信息。光流分析可以用于解决各种运动问题——摄像机静止目标运动、摄像机运动目标静止、两者都运动。光流场刻画了物体运动的速度大小及方向，二维光流场包含了运动速度信息和时间相干信息。</p><h1 id="稀疏光流与稠密光流"><a href="#稀疏光流与稠密光流" class="headerlink" title="稀疏光流与稠密光流"></a>稀疏光流与稠密光流</h1><p>稀疏光流只计算某些特征明显的像素点的运动。稀疏光流估计最经典的算法是Lucas-Kanade method (KL)。<br>稠密光流计算图像上所有像素点的运动。稠密光流是 Farneback。<br>下图中作图为稀疏光流，右图为稠密光流。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/%E5%9B%BE%E7%89%873.gif"></p><h2 id="怎么看稠密光流图"><a href="#怎么看稠密光流图" class="headerlink" title="怎么看稠密光流图"></a>怎么看稠密光流图</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412205202.png" alt="20230412205202"><br>上图中左图为第1帧图像，中间为第二帧图像，右图为第三帧图像。<br>在光流图中，<strong>不同颜色表示不同的运动方向</strong>，<strong>深浅表示运动的速度</strong>。其参考图如下所示：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412205322.png" alt="20230412205322"><br>所以可以知道视频中的右边米白色沙发大概是向右上角做平移。</p><h1 id="中间流与双向流"><a href="#中间流与双向流" class="headerlink" title="中间流与双向流"></a>中间流与双向流</h1><p>视频插帧的目标是在两个相邻的视频帧 $I_{0}$ 和 $I_{1}$ 之间，生成中间时刻的视频帧 $I_{t} (0 &lt; t &lt; 1)$ 。在模型训练阶段，我们有 $I_{t}$ 的数据。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412205525.png" alt="20230412205525">    </p><h2 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h2><p>其中，我们令$I_{0}$到$I_{1}$的光流为$F_{0\rightarrow1}$,令$I_{1}$到$I_{0}$的光流为$F_{1\rightarrow0}$。$F_{0\rightarrow1}$和$F_{1\rightarrow0}$则被我们称之为双向流，即第一张图到第二张图的光流和第二张图到第一张图的光流。</p><h2 id="中间流"><a href="#中间流" class="headerlink" title="中间流"></a>中间流</h2><p>假设我们现在已经有了中间插值的这张图片$I_{t}$，我们计算$I_{t}$到$I_{1}$的光流记为$F_{t\rightarrow1}$,计算$I_{t}$到$I_{0}$的光流记为$F_{t\rightarrow0}$，则$F_{t\rightarrow1}$和$F_{t\rightarrow0}$被我们称之为中间流，即中间帧图像到两边帧图像的光流。</p><h1 id="光流估计插帧任务的常用方法"><a href="#光流估计插帧任务的常用方法" class="headerlink" title="光流估计插帧任务的常用方法"></a>光流估计插帧任务的常用方法</h1><p>首先，估计双向光流，分别用$F_{0\rightarrow1}$和$F_{1\rightarrow0}$表示。为合成中间帧，有两种常见的策略：   </p><ul><li>第一种策略可以应用<strong>前向变形</strong>，基于$F_{0\rightarrow1}$变形$I_{0}$并且基于$F_{1\rightarrow0}$变形$I_{1}$，然而前向变形可能导致变形图像出现“洞”；    </li><li>第二种策略是先近似中间流，即$F_{t\rightarrow1}$和$F_{t\rightarrow0}$，然后应用<strong>后向变形</strong>对输入帧采样，而为了近似中间流，可以从$F_{0\rightarrow1}$和$F_{1\rightarrow0}$ 中的相同网格坐标借用光流矢量，或者聚合通过同一位置的光流向量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之RIFE</title>
      <link href="/2023/04/18/VFI-RIFE/"/>
      <url>/2023/04/18/VFI-RIFE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>论文地址：<a href="https://arxiv.org/pdf/2011.06294.pdf">RIFE：Real-Time Intermediate Flow Estimation for Video Frame Interpolation</a><br>项目主页： <a href="https://zhuanlan.zhihu.com/p/568553080">https://zhuanlan.zhihu.com/p/568553080</a><br>github代码：<a href="https://github.com/hzwer/arXiv2020-RIFE">Pytorch版本</a></p><h1 id="RIFE"><a href="#RIFE" class="headerlink" title="RIFE"></a>RIFE</h1><p>RIFE有两个重要组成部分：    </p><ol><li>使用IFNet进行有效的中间流估算。</li><li>使用FusionNet对warp后的帧进行融合处理。</li></ol><h2 id="RIFE网络总体结构"><a href="#RIFE网络总体结构" class="headerlink" title="RIFE网络总体结构"></a>RIFE网络总体结构</h2><p>RIFE的总体框架如下图所示，其主要由IFNet、Backward Warp以及Fusion Process三个模块组成，其中RIFE的核心功能是由IFNet与Fusion实现的，因此后文我会着重介绍这两部分内容。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412222613.png" alt="20230412222613"><br>RIFE的大致流程是先给定两张连续的帧,和取值范围为0到1的步长t，根据步长t来确定合成的中间帧的数量。IFNet先是直接对输入帧估计中间流信息，然后假设为线性运动从而估计，公式如下∶<br>$$<br>F_{t\rightarrow 1}&#x3D;-\frac{1-t}{t}F_{t\rightarrow 0}<br>$$<br>这就是IFNet光流估计与传统的利用双向光流进行中间流估计最大的区别。IFNet只进行了一次光流估计,处理起来十分迅速,而传统的双向光流估计则需要估计两次,处理起来就会很级慢。在完成光流估计后,接下来就需要warp连续两帧得到中间帧。为了估算中间流$F_{t\rightarrow0}$，$F_{t\rightarrow1}$和融合图M,需要将输入帧和通道t输入IFNet。然后根据下面的公式重建目标帧:<br>$$<br>\hat{I}<em>{t} &#x3D; M \odot \hat{I}</em>{t \leftarrow 0 } +(1-M)\odot \hat{I}<em>{t \leftarrow 1 }<br>$$<br>$$<br>\hat{I}</em>{t \leftarrow 0 } &#x3D; W(I_{0},F_{t\rightarrow 0} ),\hat{I}<em>{t \leftarrow 1 } &#x3D; W(I</em>{1},F_{t\rightarrow 1} )<br>$$<br>其中W是图像向后warp, $\odot$ 是逐元素乘法符号,(0≤M≤1)。RIFE使用了另一个编解码CNN网络RefineNet改善高频区域和减少学生模型的失真。这种方法类似Super Slomo，DAIN等视频插帧方案，这里的FusionNet包含一个上下文特征提取模块和融合模块(U-Net结构)，上下文特征提取模块和融合模块的编码部分具有相似的结构，即包含4个stride&#x3D;2的ResBlock；融合模块的解码模块包含4个反卷积进行特征分辨率上采样。最后，对融合结果进行范围约束。      </p><h2 id="中间流估计以及中间帧重建"><a href="#中间流估计以及中间帧重建" class="headerlink" title="中间流估计以及中间帧重建"></a>中间流估计以及中间帧重建</h2><p>传统的中间流估算方法由两步组成：   </p><ol><li>估算双向光流   </li><li>光流逆转</li></ol><p>但这种方法在运动边界可能出错。因此RIFE提出了一种直接估计中间流的方法，IFNET，如下图所示：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412222642.png" alt="20230412222642"><br>流逆转过程通常很麻烦,因为处理物体位置的改变很困难。IFNet可以直接估算中间光流。直观的说,以前的流逆转方法希望在光流场上做空间插值,这并不比对RGB图像做空间插帧简单。<br>而IFNet可以直接高效的预测$F_{t\rightarrow 0}$ ,$F_{t\rightarrow 1}$和融合图M,当t &#x3D;0,或t &#x3D;1时, IFNet就是一个经典的双向光流模型。</p><p>为了处理大运动场景，RIFE使用了由粗到精逐步增加分辨率的策略，如下图所示。具体的说，我们首先在低分辨率下计算一个比较粗的流预贬结果，这使得更容易捕捉大运动，然后逐步增加分辨率来迭代求精流场(flowfiled)。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412222705.png" alt="20230412222705"><br>IFNet的这种光流估计方式可以描述如下:<br>$$<br>(F,M)^{i} &#x3D; (F,M)^{i-1} + g^{i}(F^{i-1},M^{i-1},I^{i-1})<br>$$<br>$(F,M)^{i-1}$ 表示从第$(i-1)$个IFBlock得到的当前中间流估算和融合图,$g^{i}$ 表示第i个IFBlock。一共使用了3个IFBlock,每个IFBlock具有一个分辨率参数K,K &#x3D;(4,2,1),以及上采样操作、6个ResBlock以及一个上采样模块。在推理时,最终的估算结果是(F, M )2。为了设计的简洁,每个IFBlock是由几个卷积层和一个上采样操作组成的前馈(feedforward)结构。除了输出光流残差和融合图的层,都采用了PReLU激活函数。<br>在得到$F_{t\rightarrow 0}$ , $F_{t\rightarrow 1}$ 后，我们就可以通过BackwardWarp得到重建结果$I_{0\rightarrow t}$,$I_{1\rightarrow t}$。</p><h2 id="IFNET的特权蒸馏"><a href="#IFNET的特权蒸馏" class="headerlink" title="IFNET的特权蒸馏"></a>IFNET的特权蒸馏</h2><p>直接逼近中间流是很难的，因为拿不到中间帧，同时缺少监督。为了解决这个问题，RIFE为IFNET设计了特权蒸馏损失(privileged distillation loss)。在训练阶段，通过$I_{0}$，$I_{1}$连续时刻的两帧，以及一个额外的时序t作为输入，送入学生模型中，输出为t一&gt;0和t-&gt;1时刻的估计光流$F_{t\rightarrow 0}$,$F_{t\rightarrow 1}$,以及用于融合的掩模M。同时, $I_{0},I_{1},t,T^{GT}_t$ 监督。具体流程如下图所示:<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230412222457.png" alt="20230412222457"><br>…………待补充  知识蒸馏方法还要去学怎么用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/613997863">https://zhuanlan.zhihu.com/p/613997863</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频插帧之DVF</title>
      <link href="/2023/04/18/VFI-DVF/"/>
      <url>/2023/04/18/VFI-DVF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2017年的视频插帧算法，使用的是类似于Unet的网络模型。整体结构比较简单，适合对视频插帧领域入门学习。<br>论文地址：<a href="https://arxiv.org/abs/1702.02463v2">Video Frame Synthesis using Deep Voxel Flow</a><br>项目主页： <a href="https://liuziwei7.github.io/projects/VoxelFlow">https://liuziwei7.github.io/projects/VoxelFlow</a><br>github代码：<a href="https://github.com/lxx1991/pytorch-voxel-flow">Pytorch版本</a><br><a href="https://github.com/liuziwei7/voxel-flow">TensorFlow版本</a></p><h1 id="DVF"><a href="#DVF" class="headerlink" title="DVF"></a>DVF</h1><p>传统的基于光流的解决方案往往在流量估计具有挑战性的情况下失败，而直接产生像素值的基于神经网络的方法往往会产生模糊的结果。DVF结合这两种方法的优点，该方法可以通过以连续三帧图像作为训练数据，以1，3帧作为输入，中间第二帧作为输出无监督训练网络。训练好的模型可以通过连续两帧图像直接生成中间图像（也可以生成两帧外的图像，即外插帧）。</p><h2 id="模型pipeline"><a href="#模型pipeline" class="headerlink" title="模型pipeline"></a>模型pipeline</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411214638.png" alt="20230411214638"><br>算法首先通过两张连续图片作为输入，通过卷积层和max pooling层多次encoder，再通过多次反卷积还原图像维度（很想unet的结构）。此时输出的时两张图像的体素流数据voxel flow layer，是一种3D的时空光流向量（其实个人认为就是光流估计中间流数据加上时间维度数据的变形）。紫色部分使用体素流和三线性插值方法对两张原始图像进行还原输出中间帧。   </p><p>体素流和三线性插值方法可参考本博客中的文章。</p><p>论文中还介绍了一种多尺度的插值方法，可以自己去看。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://arxiv.org/abs/1702.02463v2">Video Frame Synthesis using Deep Voxel Flow</a><br><a href="https://zhuanlan.zhihu.com/p/404590100">https://zhuanlan.zhihu.com/p/404590100</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络之Unet</title>
      <link href="/2023/04/18/nn-Unet/"/>
      <url>/2023/04/18/nn-Unet/</url>
      
        <content type="html"><![CDATA[<p>super—slomo图像插值算法中间使用了两个Unet网络，这里对Unet进行介绍。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20230411154443.png" alt="20230411154443"><br>输入: 1*572*572<br>输出: 2*388*388<br>（1）UNet采用全卷积神经网络。<br>（2）左边网络为特征提取网络：使用conv和pooling<br>（3）右边网络为特征融合网络：使用上采样产生的特征图与左侧特征图进行concatenate操作。（pooling层会丢失图像信息和降低图像分辨率且是永久性的，对于图像分割任务有一些影响，对图像分类任务的影响不大，为什么要做上采样呢？上采样可以让包含高级抽象特征低分辨率图片在保留高级抽象特征的同时变为高分辨率，然后再与左边低级表层特征高分辨率图片进行concatenate操作）<br>（4）最后再经过两次卷积操作，生成特征图，再用两个卷积核大小为1*1的卷积做分类得到最后的两张heatmap，例如第一张表示第一类的得分，第二张表示第二类的得分heatmap，然后作为softmax函数的输入，算出概率比较大的softmax，然后再进行loss，反向传播计算。     </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是根据UNet模型搭建出的一个基本网络结构</span></span><br><span class="line"><span class="string">输入和输出大小是一样的，可以根据需求进行修改</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本卷积块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C_in, C_out</span>):</span><br><span class="line">        <span class="built_in">super</span>(Conv, self).__init__()</span><br><span class="line">        self.layer = nn.Sequential(</span><br><span class="line"></span><br><span class="line">            nn.Conv2d(C_in, C_out, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(C_out),</span><br><span class="line">            <span class="comment"># 防止过拟合</span></span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.LeakyReLU(),</span><br><span class="line"></span><br><span class="line">            nn.Conv2d(C_out, C_out, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(C_out),</span><br><span class="line">            <span class="comment"># 防止过拟合</span></span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            nn.LeakyReLU(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.layer(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下采样模块 max pool层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DownSampling</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C</span>):</span><br><span class="line">        <span class="built_in">super</span>(DownSampling, self).__init__()</span><br><span class="line">        self.Down = nn.Sequential(</span><br><span class="line">            <span class="comment"># 使用卷积进行2倍的下采样，通道数不变</span></span><br><span class="line">            nn.Conv2d(C, C, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">            nn.LeakyReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.Down(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上采样模块 up-conv层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpSampling</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C</span>):</span><br><span class="line">        <span class="built_in">super</span>(UpSampling, self).__init__()</span><br><span class="line">        <span class="comment"># 特征图大小扩大2倍，通道数减半</span></span><br><span class="line">        self.Up = nn.Conv2d(C, C // <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, r</span>):</span><br><span class="line">        <span class="comment"># 使用邻近插值进行下采样</span></span><br><span class="line">        up = F.interpolate(x, scale_factor=<span class="number">2</span>, mode=<span class="string">&quot;nearest&quot;</span>)</span><br><span class="line">        x = self.Up(up)</span><br><span class="line">        <span class="comment"># 拼接，当前上采样的，和之前下采样过程中的</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((x, r), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主干网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(UNet, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4次下采样</span></span><br><span class="line">        self.C1 = Conv(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">        self.D1 = DownSampling(<span class="number">64</span>)</span><br><span class="line">        self.C2 = Conv(<span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">        self.D2 = DownSampling(<span class="number">128</span>)</span><br><span class="line">        self.C3 = Conv(<span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">        self.D3 = DownSampling(<span class="number">256</span>)</span><br><span class="line">        self.C4 = Conv(<span class="number">256</span>, <span class="number">512</span>)</span><br><span class="line">        self.D4 = DownSampling(<span class="number">512</span>)</span><br><span class="line">        self.C5 = Conv(<span class="number">512</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4次上采样</span></span><br><span class="line">        self.U1 = UpSampling(<span class="number">1024</span>)</span><br><span class="line">        self.C6 = Conv(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.U2 = UpSampling(<span class="number">512</span>)</span><br><span class="line">        self.C7 = Conv(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.U3 = UpSampling(<span class="number">256</span>)</span><br><span class="line">        self.C8 = Conv(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">        self.U4 = UpSampling(<span class="number">128</span>)</span><br><span class="line">        self.C9 = Conv(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">        self.Th = torch.nn.Sigmoid()</span><br><span class="line">        self.pred = torch.nn.Conv2d(<span class="number">64</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 下采样部分</span></span><br><span class="line">        R1 = self.C1(x)</span><br><span class="line">        R2 = self.C2(self.D1(R1))</span><br><span class="line">        R3 = self.C3(self.D2(R2))</span><br><span class="line">        R4 = self.C4(self.D3(R3))</span><br><span class="line">        Y1 = self.C5(self.D4(R4))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上采样部分</span></span><br><span class="line">        <span class="comment"># 上采样的时候需要拼接起来</span></span><br><span class="line">        O1 = self.C6(self.U1(Y1, R4))</span><br><span class="line">        O2 = self.C7(self.U2(O1, R3))</span><br><span class="line">        O3 = self.C8(self.U3(O2, R2))</span><br><span class="line">        O4 = self.C9(self.U4(O3, R1))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出预测，这里大小跟输入是一致的</span></span><br><span class="line">        <span class="comment"># 可以把下采样时的中间抠出来再进行拼接，这样修改后输出就会更小</span></span><br><span class="line">        <span class="keyword">return</span> self.Th(self.pred(O4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">    net = UNet()</span><br><span class="line">    <span class="built_in">print</span>(net(a).shape)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像评价常用指标</title>
      <link href="/2023/04/04/image-eva/"/>
      <url>/2023/04/04/image-eva/</url>
      
        <content type="html"><![CDATA[<p>论文中测试生成图像数据的评估指标，可用于光流估计、图像插帧等</p><h1 id="PSNR：峰值信噪比"><a href="#PSNR：峰值信噪比" class="headerlink" title="PSNR：峰值信噪比"></a>PSNR：峰值信噪比</h1><p>PSNR全称为“Peak Signal-to-Noise Ratio”，中文意思即为峰值信噪比，是衡量图像质量的指标之一。<br>图像与影像压缩中典型的峰值讯噪比值在30dB 到50dB 之间，越高越好。</p><ul><li>$PSNR\approx50dB$  ，代表压缩后的图像仅有些许非常小的误差。</li><li>$PSNR&gt;30dB$  ，人眼很难察觉压缩后和原始影像的差异。</li><li>$PSNR \in [20dB ,30dB]$，人眼就可以察觉出图像的差异。</li><li>$PSNR \in [10dB ,20dB]$，人眼还是可以用肉眼看出这个图像原始的结构，且直观上会判断两张图像不存在很大的差异。</li><li>$PSNR&lt;10dB$，人类很难用肉眼去判断两个图像是否为相同，一个图像是否为另一个图像的压缩结果。</li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>PSNR是基于MSE(均方误差)定义，对给定一个大小为m*n的原始图像I和对其添加噪声后的噪声图像K，其MSE可定义为：<br>$$<br>MSE&#x3D;\frac{1}{m n} \sum_{i&#x3D;0}^{m-1} \sum_{j&#x3D;0}^{n-1}[I(i, j)-K(i, j)]^{2}<br>$$<br>则PSNR可定义为:<br>$$<br>P S N R&#x3D;10 \cdot \log <em>{10}\left(\frac{M A X</em>{I}^{2}}{M S E}\right)&#x3D;20 \cdot \log <em>{10}\left(\frac{M A X</em>{I}}{\sqrt{M S E}}\right)<br>$$<br>其中MAXI为图像的最大像素值，PSNR的单位为dB。若每个像素由8位二进制表示，则其值为2^8-1&#x3D;255。但注意这是针对灰度图像的计算方法，若是彩色图像，通常可以由以下方法进行计算：</p><ul><li><p>方法一：计算RGB图像三个通道每个通道的MSE值再求平均值，进而求PSNR</p></li><li><p>方法二：直接使用matlab的内置函数psnr()(注意该函数将所有图像当成灰度图像处理)。</p></li><li><p>方法三：将图像转为YCbCr格式，只计算Y分量即亮度分量的PSNR。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> peak_signal_noise_ratio <span class="keyword">as</span> psnr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img1 = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;original.jpg&#x27;</span>))</span><br><span class="line">img2 = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;compress.jpg&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(psnr(img1, img2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>matlab实现：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PSNR</span> = <span class="title">psnr</span><span class="params">(f1, f2)</span></span></span><br><span class="line"><span class="comment">%计算两幅图像的峰值信噪比</span></span><br><span class="line">k = <span class="number">8</span>;</span><br><span class="line"><span class="comment">%k为图像是表示地个像素点所用的二进制位数，即位深。</span></span><br><span class="line">fmax = <span class="number">2.</span>^k - <span class="number">1</span>;</span><br><span class="line">a = fmax.^<span class="number">2</span>;</span><br><span class="line">MSE =(double(im2uint8(f1)) -double( im2uint8(f2))).^<span class="number">2</span>;</span><br><span class="line">b = <span class="built_in">mean</span>(<span class="built_in">mean</span>(MSE));</span><br><span class="line">PSNR = <span class="number">10</span>*<span class="built_in">log10</span>(a/b);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SSIM：结构相似性"><a href="#SSIM：结构相似性" class="headerlink" title="SSIM：结构相似性"></a>SSIM：结构相似性</h1><p>SSIM 测量两个图像之间的相似性。人类对像素的绝对亮度&#x2F;颜色不敏感，但对边缘和纹理的位置非常敏感。 SSIM 通过主要关注边缘和纹理相似性来模仿人类感知。一般取值范围：0-1.值越大，质量越好。</p><h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><p>SSIM分别在亮度 (luminance   l(x，y)）、对比度 (contrast   c(x，y)) 和结构 (structure  s(x，y))三个方面进行比较。<br>$$<br>\operatorname{SSIM}(\mathbf{x}, \mathbf{y})&#x3D;[l(\mathbf{x}, \mathbf{y})]^{\alpha}[c(\mathbf{x}, \mathbf{y})]^{\beta}[s(\mathbf{x}, \mathbf{y})]^{\gamma}<br>$$<br>其中，l(x，y)比较x和y的亮度，c(x，y)比较x和y的对比度，s(x，y)比较x和y的结构。C1、C2、C3是正值常数，用于防止公式出现除0异常。</p><h3 id="简化公式"><a href="#简化公式" class="headerlink" title="简化公式"></a>简化公式</h3><p>$$<br>\operatorname{SSIM}(\mathbf{x}, \mathbf{y})&#x3D;\frac{\left(2 \mu_{x} \mu_{y}+C_{1}\right)\left(2 \sigma_{x y}+C_{2}\right)}{\left(\mu_{x}^{2}+\mu_{y}^{2}+C_{1}\right)\left(\sigma_{x}^{2}+\sigma_{y}^{2}+C_{2}\right)}<br>$$<br>C1、C2、C3是正值常数，用于防止公式出现除0异常。<br>$C_1&#x3D;(K_1<em>L)</em>(K_1<em>L)$<br>$C_2&#x3D;(K_2</em>L)<em>(K_2</em>L)$<br>$C_3&#x3D;C_2&#x2F;2$<br>默认 $K_1 &#x3D; 0.01，K_2 &#x3D; 0.03$,$L&#x3D;2^B-1$,B是比特深度。常用8bit，所以L值一般是255。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.measure <span class="keyword">import</span> compare_ssim</span><br><span class="line"><span class="built_in">print</span>(compare_ssim(img1, img2,data_range=<span class="number">255</span>,multichannel=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h1 id="LPIPS-图像相似性度量标准（感知损失）"><a href="#LPIPS-图像相似性度量标准（感知损失）" class="headerlink" title="LPIPS 图像相似性度量标准（感知损失）"></a>LPIPS 图像相似性度量标准（感知损失）</h1><p>该度量标准学习生成图像到Ground Truth的反向映射强制生成器学习从假图像中重构真实图像的反向映射，并优先处理它们之间的感知相似度。LPIPS 比传统方法（比如L2&#x2F;PSNR, SSIM, FSIM）更符合人类的感知情况。LPIPS的值越低表示两张图像越相似，反之，则差异越大。</p><h2 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h2><p>$$<br>d\left(x, x_{0}\right)&#x3D;\sum_{l} \frac{1}{H_{l} W_{l}} \sum_{h, w}\left|w_{l} \odot\left(\hat{y}<em>{h w}^{l}-\hat{y}</em>{0 h w}^{l}\right)\right|_{2}^{2}<br>$$<br>d为 x0与x之间的距离。从L层提取特征堆(feature stack)并在通道维度中进行单位规格化(unit-normalize)。利用向量WL 来放缩激活通道数,最终计算L2距离。最后在空间上平均，在通道上求和。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lpips</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_of_lpips</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, net, use_gpu=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        net: str</span></span><br><span class="line"><span class="string">            抽取特征的网络，[&#x27;alex&#x27;, &#x27;vgg&#x27;]</span></span><br><span class="line"><span class="string">        use_gpu: bool</span></span><br><span class="line"><span class="string">            是否使用GPU，默认不使用</span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        References</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        https://github.com/richzhang/PerceptualSimilarity/blob/master/lpips_2imgs.py</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">## Initializing the model</span></span><br><span class="line">        self.loss_fn = lpips.LPIPS(net=net)</span><br><span class="line">        self.use_gpu = use_gpu</span><br><span class="line">        <span class="keyword">if</span> use_gpu:</span><br><span class="line">            self.loss_fn.cuda()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_lpips</span>(<span class="params">self, img1_path, img2_path</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        img1_path : str</span></span><br><span class="line"><span class="string">            图像1的路径.</span></span><br><span class="line"><span class="string">        img2_path : str</span></span><br><span class="line"><span class="string">            图像2的路径.</span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        dist01 : torch.Tensor</span></span><br><span class="line"><span class="string">            学习的感知图像块相似度(Learned Perceptual Image Patch Similarity, LPIPS).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        References</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        https://github.com/richzhang/PerceptualSimilarity/blob/master/lpips_2imgs.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># Load images</span></span><br><span class="line">        img0 = lpips.im2tensor(lpips.load_image(img1_path))  <span class="comment"># RGB image from [-1,1]</span></span><br><span class="line">        img1 = lpips.im2tensor(lpips.load_image(img2_path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.use_gpu:</span><br><span class="line">            img0 = img0.cuda()</span><br><span class="line">            img1 = img1.cuda()</span><br><span class="line">        dist01 = self.loss_fn.forward(img0, img1)</span><br><span class="line">        <span class="keyword">return</span> dist01</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h1><h2 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h2><p>$$<br>\operatorname{IE} &#x3D; \left[ \frac{1}{N}\sum_{(x,y)}(I(x, y) - I_{GT}(x, y))^2 \right]^{\frac{1}{2}}<br>$$<br>N代表图片像素的个数</p><p>论文地址：<a href="https://link.springer.com/article/10.1007/s11263-010-0390-2">A Database and Evaluation Methodology for Optical Flow</a>   </p><h1 id="光流估计评估方法"><a href="#光流估计评估方法" class="headerlink" title="光流估计评估方法"></a>光流估计评估方法</h1><p>以上介绍都是对于生成图像与ground truth的比较，一下介绍光流估计中的评价指标：</p><h2 id="EPE-x2F-EE-Endpoint-Error"><a href="#EPE-x2F-EE-Endpoint-Error" class="headerlink" title="EPE&#x2F;EE(Endpoint Error)"></a>EPE&#x2F;EE(Endpoint Error)</h2><p>EPE(Endpoint Error)，是光流估计中标准的误差度量，是预测光流向量与真实光流向量的欧氏距离在所有像素上的均值。（越低越好）</p><h3 id="公式-4"><a href="#公式-4" class="headerlink" title="公式"></a>公式</h3><p>$$<br>\operatorname{EPE}&#x3D;\sqrt{\left(\left(\mathrm{u}<em>{\mathrm{est}}-\mathrm{u}</em>{\mathrm{gt}}\right)^{2}+\left(\mathrm{v}<em>{\mathrm{est}}-\mathrm{v}</em>{\mathrm{gt}}\right)^{2}\right)}<br>$$</p><h2 id="AE-Angular-Error"><a href="#AE-Angular-Error" class="headerlink" title="AE(Angular Error)"></a>AE(Angular Error)</h2><p>光流是使用了类似平面直角坐标系中的坐标形式来表达，而该坐标同时可以表示为一个向量。由此可以引入另一个评价指标AE。</p><p>AE(Angular Error)，是计算光流向量之间的角度误差（此处加了一个维度，从原来的(u, v) 变成 (u, v, 1)）。</p><h3 id="公式-5"><a href="#公式-5" class="headerlink" title="公式"></a>公式</h3><p>$$<br>AE &#x3D; \arccos(\frac{(u_{est},v_{est},1)^T *(u_{gt},v_{gt},1)}{\sqrt{1.0+u_{est}^2+v_{est}^2}\sqrt{1.0+u_{gt}^2+v_{gt}^2}})<br>$$<br>新的评价方法更新中…</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/541385224?utm_id=0">https://zhuanlan.zhihu.com/p/541385224?utm_id=0</a><br><a href="https://blog.csdn.net/weixin_43135178/article/details/118497369">https://blog.csdn.net/weixin_43135178/article/details/118497369</a><br><a href="https://mapengsen.blog.csdn.net/article/details/127486035">https://mapengsen.blog.csdn.net/article/details/127486035</a><br><a href="https://blog.csdn.net/weixin_43466026/article/details/119898304">https://blog.csdn.net/weixin_43466026/article/details/119898304</a><br><a href="https://aistudio.baidu.com/aistudio/projectdetail/4597614">https://aistudio.baidu.com/aistudio/projectdetail/4597614</a><br><a href="https://link.springer.com/article/10.1007/s11263-010-0390-2">A Database and Evaluation Methodology for Optical Flow</a>   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频压缩算法名词解释</title>
      <link href="/2022/12/05/videoCompressionKeyWord/"/>
      <url>/2022/12/05/videoCompressionKeyWord/</url>
      
        <content type="html"><![CDATA[<p>常见视频压缩算法中的基本概念总结</p><h1 id="视频压缩关键词"><a href="#视频压缩关键词" class="headerlink" title="视频压缩关键词"></a>视频压缩关键词</h1><ol><li>空间冗余<br>一幅静态图像，比如人脸。背景，人脸，头发等处的亮度，颜色，都是<em><strong>平缓变化</strong></em>的。相邻的像素和色度信号值比较接近。具有强相关性，如果直接用采样数来表示亮度和色度信息，数据中存在较多的空间冗余。如果先<strong>去除冗余数据</strong>再编码，表示每个像素的平均比特数就会下降，这就是通常说的图像的<strong>帧内编码</strong>，即以减少空间冗余进行数据压缩。</li><li>时间冗余<br>视频是时间轴方向的帧图像序列，相邻帧图像的相关性也很强。通常用降低帧间的方法来减少时间冗余。采用<strong>运动估计和运动补偿</strong>的技术满足解码重建图像的质量要求。    </li><li>符号冗余<br>用相同码表示<strong>概率不同的符号</strong>，会造成比特数的浪费。比如10，11，13三个数，如果我们都用1bytes来表示，就是3bytes(即3×8 &#x3D; 24bits)，但是如果我们表00b表示10，01b表示11，02b表示13，这样，三个数合起来才用了6bits，较之前可以节省18bits。<br>可变长编码技术的原理就如此，<strong>概论大的用较短的码字，概率小的用较长的码字</strong>。   </li><li>结构冗余<br>对于图像内部，各个部分也存在某种关系。我们可以通过这种关系，减少信息的码字表达。比如:分形图像编码    </li><li>视觉冗余<br>1）人眼对彩色信号的亮度分辨率高于色彩分辨率，比如rgb–&gt;yuv就是这个原理<br>2）人眼对静止图像的空间的分辨率大于运动图像的分辨率。<br>3）人眼对亮度的细小变化不敏感<br>4）中心敏感，四周不敏感。</li></ol><p>其实我们虽然知道了这些，我们知道有冗余，但是如何把这些冗余找出来，是个很复杂的过程。也是我们的算法不断追求的过程。<br>上面的一段，是所有视频压缩标准的基石。mpeg2,mpeg4,h264,h265这些标准，与其说他们是标准，不如他们提供了一些算法的组合，或简单或复杂，当然简单的算法压缩掉的冗余小，复杂的压缩掉的冗余大。通过算法找到冗余信息在哪，然后压缩掉，实现数据量的减小。这就是我们的目录。<br>更近一步的说，就是我们如何找出<strong>数据的相关性</strong>。</p><h1 id="变换与编码"><a href="#变换与编码" class="headerlink" title="变换与编码"></a>变换与编码</h1><p>我们要找出信号的相关性，时间上不好找怎么办，变换到另外一个空间上去。这就是我们在信号与系统，数字信号处理，高等数学得到的结论  </p><h2 id="常见变换"><a href="#常见变换" class="headerlink" title="常见变换"></a>常见变换</h2><p>傅里叶变换</p><p>walsh-hadamard(沃尔什哈达玛变换）</p><p>正弦变换</p><p>余弦变换—-应用最广</p><p>斜变换</p><p>哈尔变换</p><p>k-L变换</p><p>小波变换</p><p>对于这些变换来说，很多东西只在数学上有意义，对于工程来说，或者没有快速算法，或者变换后相关性比较低，或者其他原因。只有余弦变换是最最广泛的，为了减小我们的学习压力（当然如果你是要对比其中的差异的另当别论），我们只掌握余弦变换就可以了。</p><h2 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h2><p>又分无失真编码与限失真编码，从名字上我们就可以看出差异了。</p><p>无失真编码的种类：</p><p>哈夫曼编码，算术编码，游程编码</p><p>限失真编码</p><p>预测编码，变换编码，矢量量化，基于模型的编码。</p><p>对于编码这块，上述的算法，基本要全部掌握才行。</p><p>jpeg&#x2F;mpeg2先用了游程编码减小的0这个数占用的比特位，然后用了哈夫曼压缩。</p><p>h264用了算术编码来做最后一道压缩工序</p><p>运动补偿与运动估计，用到预测编码。</p><p>mpeg4用到了基于模型的编码</p><p>变换完成后，进行了矢量量化。</p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vidoCompression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/05/hello-world/"/>
      <url>/2022/12/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fiddler界面讲解及抓包教程</title>
      <link href="/2022/11/22/fiddlerTuitor/"/>
      <url>/2022/11/22/fiddlerTuitor/</url>
      
        <content type="html"><![CDATA[<p>学校的打卡老是忘，所以准备抓个包写一个自动打卡的脚本，这里记录一下fiddler软件的界面以及https配置和手机抓包教程。</p><h1 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h1><h2 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122154551.png" alt="20221122154551"><br>不介绍，和其他应用程序一样</p><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122154628.png" alt="20221122154628">    </p><p>winconfig: 打开对windows IE浏览器的配置<br>气泡： 对选中的session添加被指<br>replay： 重发选中的session<br>叉： 删除列表中的session<br>GO： 当有断点时，继续断点的运行<br>Stream: 流模式；使用流模式不能控制服务器的响应，服务器响应什么数据就展示什么数据，流模式更接近于浏览器本身真实的行为。    </p><blockquote><p>不点开为缓冲模式：可控制服务器的响应，如对响应的数据进行修改等等。        </p></blockquote><p>Decode： 自动对数据进行解码<br>Keep All sessions: session在列表中显示的个数<br>target： 点击长按拖动到某一程序，可以仅查看这一进程的数据包<br>find： 搜索某文本<br>save： 保存列表中的session为saz文件<br>截图： 不知道为啥需要截图<br>定时器： 计时功能<br>Browse： 打开浏览器<br>Clear Cache： 清除浏览器缓存<br>TextWizard： 编码转换窗口，可以对文本进行编解码<br>Tearoff： 让内容窗口悬浮     </p><h2 id="列表窗口"><a href="#列表窗口" class="headerlink" title="列表窗口"></a>列表窗口</h2><p>显示已经捕获的session内容，可自行添加列<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122160114.png" alt="20221122160114">     </p><h2 id="内容窗口"><a href="#内容窗口" class="headerlink" title="内容窗口"></a>内容窗口</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122160217.png" alt="20221122160217"><br>红线以上为请求，以下为响应    </p><h3 id="最上面一排工具栏"><a href="#最上面一排工具栏" class="headerlink" title="最上面一排工具栏"></a>最上面一排工具栏</h3><p>统计： 计算响应时间等数据<br>监控器： 显示数据包中的内容<br>自动响应： 可设置规则以固定内容响应对应域名发来的响应<br>创造器： 模拟各种请求，自定义请求头和body（可从列表中直接拖过来发送一样的请求）<br>Log： 运行日志<br>Filters： 过滤器，只接收某域名的数据包等操作<br>timeline： 查看请求响应的时长，列表里可多选session，timeline里会显示延时长度     </p><h2 id="终端及状态栏"><a href="#终端及状态栏" class="headerlink" title="终端及状态栏"></a>终端及状态栏</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122161143.png" alt="20221122161143"><br>终端： 可输入命令操作<br>capturing： 正在抓取数据包，点一下消失为不抓<br>ALL processes： 抓取所有进程，可选值只抓浏览器或非浏览器<br>中断（第三个空白的地方）：空白表示不中断；点一下是设置请求中断：请求客户端已发出，但没到服务器；再点一下为设置响应中断：响应从服务器发回，但还没到客户端。配合工具栏中的GO使用。</p><h1 id="抓取https包设置"><a href="#抓取https包设置" class="headerlink" title="抓取https包设置"></a>抓取https包设置</h1><p><code>菜单栏</code>-&gt;<code>Tools</code>-&gt;<code>Fiddler Options</code>-&gt;<code>HTTPS</code> 勾选抓取https（如果第一次装会让你安装一下fiddler的证书，一路确定就行）decrypt https 也勾上<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122162347.png" alt="20221122162347"></p><h1 id="抓手机的数据包"><a href="#抓手机的数据包" class="headerlink" title="抓手机的数据包"></a>抓手机的数据包</h1><p><code>菜单栏</code>-&gt;<code>Tools</code>-&gt;<code>Fiddler Options</code>-&gt;<code>connections</code>勾选Allow remote computers to connect 记住选择的端口<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221122162747.png" alt="20221122162747"><br>fiddler右上角的online的位置看一下本机的IP地址<br>手机连接至和电脑同一局域网的网络中，在wifi设置中设置代理。ip为电脑的ip，端口为上图中的fiddler端口。<br>手机浏览器访问：电脑ip：端口号（如： 192.168.1.1：8888）下载手机的证书并安装。<br>重启一下fiddler就能看到手机上的数据包了，一般fiddler列表中没有进程那一项的就是手机上发来的包。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10 cuda9.1安装pytorch</title>
      <link href="/2022/10/27/cuda9-1-pytorch/"/>
      <url>/2022/10/27/cuda9-1-pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直想学深度学习，奈何我的显卡是七年前的gtx970m，cuda只支持cuda9.1。去pytorch官网上看了一下没有这个版本的，所以深度学习一直只停留在理论层面。这两天好好折腾了一下，终于把pytorch装上了，下面介绍方法。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>安装CUDA和cuDNN（用于深度神经网络的GPU加速库）</li><li>安装anaconda（pytorch的版本要和python的版本对应，所以需要anaconda进行版本管理，我的torch0.4.0需要python3.6）</li><li>安装pytorch和torchversionm</li></ol><h1 id="CUDA和cuDNN安装"><a href="#CUDA和cuDNN安装" class="headerlink" title="CUDA和cuDNN安装"></a>CUDA和cuDNN安装</h1><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>windows10 版本安装 CUDA ，需要下载两个安装包</p><ul><li>CUDA toolkit（toolkit就是指工具包）</li><li>cuDNN</li></ul><p>首先你需要知道自己的显卡支持的CUDA版本，桌面-&gt;右键-&gt;NVIDIA控制面板-&gt;系统信息（左下角）-&gt;组件。第三行产品名称一栏可以看到CUDA的驱动版本。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/687669.png"><br>去CUDA官网下载对应的toolkit（<a href="https://developer.nvidia.com/cuda-toolkit-archive">下载链接</a>）<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221028105141.png"><br>下载好后直接双击安装就行了</p><blockquote><p>注意：安装cuda时，第一次会让设置临时解压目录，第二次会让设置安装目录；临时解压目录千万不要和cuda的安装路径设置成一样的，否则安装结束，会找不到安装目录的！！！</p></blockquote><h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><p>运行cmd，输入nvcc –version 即可查看版本号；</p><p>set cuda，可以查看 CUDA 设置的环境变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">set cuda</span><br></pre></td></tr></table></figure><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221028105624.png"></p><h2 id="cuDNN安装"><a href="#cuDNN安装" class="headerlink" title="cuDNN安装"></a>cuDNN安装</h2><p>cuDNN地址如下，不过要注意的是，我们需要注册一个账号，才可以进入到下载界面。大家可以放心注册的。<br><a href="https://developer.nvidia.com/rdp/cudnn-download">注册链接</a><br>下载CUDA对应的cuDNN链接：<br><a href="https://developer.nvidia.com/rdp/cudnn-archive">下载链接</a><br>下载完成后是一个压缩包，我们需要把压缩包里的内容拷贝到cuda的安装目录下。<br>默认安装目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0</span><br></pre></td></tr></table></figure><p>拷贝时看到，CUDA 的安装目录中，有和 cuDNN 解压缩后的同名文件夹，这里注意，不需要担心，直接复制即可。cuDNN 解压缩后的同名文件夹中的配置文件会添加到 CUDA安装目录中的同名文件夹中。【此处还是建议还是分别把文件夹的内容复制到对应文件夹中去】</p><p>现在大家应该可以理解，cuDNN 其实就是 CUDA 的一个补丁而已，专为深度学习运算进行优化的。然后再参加<em><strong>环境变量</strong></em>:    </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\bin</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\include</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\lib</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\libnvvp</span><br></pre></td></tr></table></figure><p>这样cuDNN也安装完成了。</p><h1 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h1><p>为什么要装Anaconda呢？主要是因为不同版本的CUDA对应了不同版本的pytorch，而pytorch的版本又对python版本有要求。所以我们需要用创建虚拟环境来保证pytorch的python版本不会影响新版本的python使用。我之前一直没装上的原因就是cuda9.1的pytorch0.4.0需要python3.6，我用的python3.7就一直有问题。有Anaconda后可以直接开一个3.6的环境，也可以开任何一个其他版本的python，互相之间不受影响。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221028154356.png"><br>Anaconda的安装和使用教程有很多，这里就不赘述。参考：<a href="https://blog.csdn.net/weixin_42570192/article/details/124726810">Anaconda 的安装及使用</a>     </p><h1 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h1><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">conda create -n 虚拟环境名 python=版本号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个python版本是3.6的python环境，命名为pytorch-gpu</span></span><br><span class="line">conda create -n pytorch-gpu python=3.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建完以后进入虚拟环节</span></span><br><span class="line">conda activate pytorch-gpu</span><br></pre></td></tr></table></figure><h2 id="pip安装pytorch0-4-0以及torchvision"><a href="#pip安装pytorch0-4-0以及torchvision" class="headerlink" title="pip安装pytorch0.4.0以及torchvision"></a>pip安装pytorch0.4.0以及torchvision</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## pytorch</span><br><span class="line">pip3 install http://download.pytorch.org/whl/cu91/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line"> </span><br><span class="line">## torchvision</span><br><span class="line">pip install torchvision==0.1.8</span><br></pre></td></tr></table></figure><p>OK,这样一来torch就安装完成，需要用的时候把python的解释器换成pytorch-gpu这个就行了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/m0_45447650/article/details/123704930">https://blog.csdn.net/m0_45447650/article/details/123704930</a><br><a href="https://blog.csdn.net/qq_43760191/article/details/121">https://blog.csdn.net/qq_43760191/article/details/121</a></p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路元件</title>
      <link href="/2022/10/24/hardwareCell/"/>
      <url>/2022/10/24/hardwareCell/</url>
      
        <content type="html"><![CDATA[<h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><p>特性： 单向导通、伏安特性<br>二极管盗用后，它的分压是0.7v<br>发光二极管导通后分得的电压为1-2V，电流值为5-20mAV<br>正向电压很小时二极管不导通，二极管正向导通电压为0.5V</p><h2 id="稳压二极管、"><a href="#稳压二极管、" class="headerlink" title="稳压二极管、"></a>稳压二极管、</h2><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221101103810.png"></p><h2 id="整流二极管"><a href="#整流二极管" class="headerlink" title="整流二极管"></a>整流二极管</h2><p>用于把交流电编程脉动直流电</p><h2 id="开关二极管"><a href="#开关二极管" class="headerlink" title="开关二极管"></a>开关二极管</h2><p>由导通变为截止或由截止变为导通所需要的时间比一般二极管短<br>主要作用：防止反向电流烧坏精密器件</p><h1 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h1><p>作用：旁路、去耦、滤波、储能。<br>旁路：1. 使输入电压均匀化，减小噪声对后级影响<br>      2. 储能，当外界信号变化过快时，及时进行补偿</p><p>去耦： 去耦电容和旁路电容作用差不多，都是滤除干扰信号的作用。旁路电容针对输入信号，去耦电容针对输出信号。<br>        去耦电容一般比较大，10uf或更大。旁路电容一般根据谐振频率是0.1uf或0.01uf</p><p>滤波： 滤除杂波，大电容滤低频，小电容滤高频</p><p>储能：收集电荷</p><h2 id="电容应用中的问题"><a href="#电容应用中的问题" class="headerlink" title="电容应用中的问题"></a>电容应用中的问题</h2><p>铝电解电容： 长脚+，短脚-，或电容上银色为负极    </p><p>瓷片电容和独石电容无极性</p><p>注意：耐压值、防止短接</p><h1 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h1><p>特点： 用输入电流控制输出电流的流控制型器件<br>三种工作状态： 放大、饱和、截止状态</p><h2 id="三极管主要参数"><a href="#三极管主要参数" class="headerlink" title="三极管主要参数"></a>三极管主要参数</h2><ol><li>共发射极电流放大系数</li><li>集电极最大允许电流Icm</li><li>集电极最大允许耗散功率Pcm</li><li>集电极-发射极间反向击穿电压Vceo</li></ol><h1 id="场效应管（mos管）"><a href="#场效应管（mos管）" class="headerlink" title="场效应管（mos管）"></a>场效应管（mos管）</h1><p>电压控电流器件。<br>三分电极：栅极G、漏极D、源极S。</p><ol><li>当电压小于1.5V的开启电压时，mos管不导通。</li><li>可变电阻区：UDS很小，电流随UGS的增大而增大</li><li>恒流区：UGS不变，UDS增大电流变化很小</li><li>击穿区：当UDS达到一定值，mos管被击穿，ID突然增大，管子易烧坏</li><li>截止区：电压小于1.5V的开启电压时，mos管不导通</li></ol><h2 id="三极管与mos管的区别"><a href="#三极管与mos管的区别" class="headerlink" title="三极管与mos管的区别"></a>三极管与mos管的区别</h2><ol><li>三极管是电流控制器件（基极电流控制三极管导电能力）<br>mos管是电压控制器件</li><li>三极管输入阻抗不高<br>mos管输入阻抗高</li><li>三极管噪声高<br>mos噪声小</li><li>三极管反应速度快<br>mos反应速度慢</li></ol><h1 id="光耦"><a href="#光耦" class="headerlink" title="光耦"></a>光耦</h1><p>实现电光电的转换</p><h1 id="瞬态电压抑制器（TVS）"><a href="#瞬态电压抑制器（TVS）" class="headerlink" title="瞬态电压抑制器（TVS）"></a>瞬态电压抑制器（TVS）</h1><p>二极管形式的高效能保护器件，防止瞬态高能量冲击，保护器件。<br>作用：</p><ol><li>加载信号和电源线上，能防止微处理器，人体静电、交流浪涌或噪声，导致处理器失灵。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpeg压缩算法(四)：编码</title>
      <link href="/2022/09/04/jpeg-algo-4/"/>
      <url>/2022/09/04/jpeg-algo-4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JPEG压缩的最后一步是对数据进行哈弗曼编码(Huffman coding)，哈弗曼几乎是所有压缩算法的基础，它的基本原理是根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。<br>举个例子，比如下面这段数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AABCBABBCDBBDDBAABDBBDABBBBDDEDBD</span><br></pre></td></tr></table></figure><p>这段数据里面包含了33个字符，每种字符出现的次数统计如下<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041732552.png"><br>如果我们用我们常见的定长编码，每个字符都是3个bit。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041733870.png"><br>那么这段文字共需要3<em>33 &#x3D; 99个bit来保存，但如果我们根据字符出现的概率，使用如下的编码<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041738120.png"><br>那么这段文字共需要$3</em>6 + 1<em>15 + 4</em>2 + 2<em>9 + 4</em>1 &#x3D; 63$个bit来保存，压缩比为63%，哈弗曼编码一般都是使用二叉树来生成的，这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041740907.png"></p><p>首先，学习JPEG编码步骤我们需要先了解一下霍夫曼编码(Huffman coding)和行程编码(RLE)</p><h1 id="霍夫曼编码原理"><a href="#霍夫曼编码原理" class="headerlink" title="霍夫曼编码原理"></a>霍夫曼编码原理</h1><p>TODO…</p><h1 id="行程编码原理-RLE"><a href="#行程编码原理-RLE" class="headerlink" title="行程编码原理(RLE)"></a>行程编码原理(RLE)</h1><p>TODO…</p><h1 id="JPEG中的编码"><a href="#JPEG中的编码" class="headerlink" title="JPEG中的编码"></a>JPEG中的编码</h1><p>我们回到JPEG压缩上，回顾上一节的内容，经过数据量化，我们现在要处理的数据是一串一维数组，举例如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041744586.png"><br>在实际的压缩过程中，数据中的0出现的概率非常高，所以首先要做的事情，是对其中的0进行处理，把数据中的非零的数据，以及数据前面0的个数作为一个处理单元。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041744990.png"><br>如果其中某个单元的0的个数超过16，则需要分成每16个一组，如果最后一个单元全都是0，则使用特殊字符“EOB”表示，EOB意思就是“后面的数据全都是0”,<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041745479.png"><br>其中（15,0）表示16个0，接下来我们要处理的是括号里右面的数字，这个数字的取值范围在-2047<del>2047之间，JPEG提供了一张标准的码表用于对这些数字编码：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041745344.png"><br>举例来说，第一个单元中的“35”这个数字，在表中的位置是长度为6的那组，所对应的bit码是“100011”，而“-6”的编码是”001″，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041745947.png"><br>括号中前两个数字分都在0</del>15之间，所以这两个数可以合并成一个byte，高四位是前面0的个数，后四位是后面数字的位数。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041746077.png"><br>对于括号前面的数字的编码，就要使用到我们提到的哈弗曼编码了，比如下面这张表，就是一张针对数据中的第一个单元，也就是直流(DC)部分的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0<del>15之间。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041751964.png"><br>举例来说，示例中的DC部分的数据是0x06，对应的二进制编码是“100”，而对于后面的交流部分，取值范围在0</del>255之间，所以对应的哈弗曼表会更大一些<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041754621.png"><br>这样经过哈弗曼编码，并且序列化后，最终数据成为如下形式<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041754021.png"><br>最终我们使用了10个字节的空间保存了原本长度为64的数组，至此JPEG的主要压缩算法结束，这些数据就是保存在jpg文件中的最终数据。  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://thecodeway.com/blog/?p=522">https://thecodeway.com/blog/?p=522</a></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>[1] <a href="http://www.impulseadventure.com/photo/jpeg-huffman-coding.html">http://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a><br>[2] <a href="http://www.mysanco.cn/index.php?class=wenku&amp;action=wenku_item&amp;id=96">http://www.mysanco.cn/index.php?class=wenku&amp;action=wenku_item&amp;id=96</a><br>[3] <a href="http://www.codingnow.com/2000/download/jpeg.txt">http://www.codingnow.com/2000/download/jpeg.txt</a><br>[4] <a href="http://jingyan.baidu.com/article/cbf0e500f1ce562eaa2893f4.html">http://jingyan.baidu.com/article/cbf0e500f1ce562eaa2893f4.html</a><br>[5] <a href="http://www.codeproject.com/Articles/83225/A-Simple-JPEG-Encoder-in-C">http://www.codeproject.com/Articles/83225/A-Simple-JPEG-Encoder-in-C</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> JPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpeg压缩算法(二)：离散余弦变换</title>
      <link href="/2022/09/04/jpeg-algo-2/"/>
      <url>/2022/09/04/jpeg-algo-2/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤三：离散余弦变换（DCT）"><a href="#步骤三：离散余弦变换（DCT）" class="headerlink" title="步骤三：离散余弦变换（DCT）"></a>步骤三：离散余弦变换（DCT）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>离散余弦变换属于傅里叶变换的另外一种形式，没错，就是大名鼎鼎的傅里叶变换。傅里叶是法国著名的数学家和物理学家，1807年，39岁的傅里叶在他的一篇论文里提出了一个想法，他认为任何周期性的函数，都可以分解为为一系列的三角函数的组合，这个想法一开始并没有得到当时科学界的承认，比如当时著名的数学家拉格朗日提出质疑，三角函数无论如何组合，都无法表达带有“尖角”的函数，一直到1822年拉格朗日死后，傅里叶的想法才正式在他的著作《热的解析理论》一书中正式发表。<br>金子总会闪光，傅里叶变换如今广泛应用于数学、物理、信号处理等等领域，变换除了它在数学上的意义外，还有其哲学上的伟大意义，那就是，世上任何复杂的事物，都可以分解为简单的事物的组合，而这个过程只需要借助数学工具就可以了。但是当年拉格朗日的质疑是正确的，三角函数的确无法表达出尖角形状的函数，不过只要三角函数足够多，可以无限逼近最终结果。比如下面这张动图，就动态描述了一个矩形方波，是如何做傅里叶分析的。<br><img src="https://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_22.jpg"><br><img src="https://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_21.gif">   </p><h2 id="离散数据DCT"><a href="#离散数据DCT" class="headerlink" title="离散数据DCT"></a>离散数据DCT</h2><p>当我们要处理的不再是函数，而是一堆离散的数据时，并且这些数据是对称的话，那么傅里叶变化出来的函数只含有余弦项，这种变换称为离散余弦变换。举个例子，有一组一维数据[x0,x1,x2,…,xn-1],那么可以通过<strong>DCT变换</strong>得到n个变换级数$F_{i}$<br>$$<br>F_ {m}&#x3D;\sum _ {i&#x3D;0}^ {n-1}x_ {k}\cos [\frac {\pi }{n}m(k+\frac {1}{2})]<br>$$<br>此时原始数据Xi可以通过**离散余弦变换变化的逆变换（IDCT)**表达出来<br>$$<br>x_ {m}&#x3D;\frac {F_ {0}}{n}+\sum _ {i&#x3D;1}^ {n-1}[\frac {2F_ {k}}{n}\cos [\frac {\pi }{n}(m+\frac {1}{2})k]]<br>$$<br>也就是说，经过DCT变换，可以把一个数组分解成数个数组的和，如果我们数组视为一个一维矩阵，那么可以把结果看做是一系列矩阵的和<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041646380.png"><br>举个例子，我们有一个长度为8的数组，内容为50,55,67,80,-10,-5,20,30，经过DCT转换，得到8个级数为287.0,106.3,14.2,-110.8,9.2,65.7,-8.2,-43.9，根据公式2.3把这个数组转换为8个新的数组的和，如果我们使用图像来表达的话，就可以发现DCT转换的有趣之处了<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041648570.png"><br>奥妙之处在于，经过DCT，数据中隐藏的规律被发掘了出来,杂乱的数据被转换成几个工整变化的数据。DCT转换后的数组中第一个是一个直线数据，因此又被称为“直流数据”，简称DC，后面的数据被称为“交流数据”，简称AC，这个称呼起源于信号分析中的术语。    </p><h2 id="JPEG压缩过程中的DCT"><a href="#JPEG压缩过程中的DCT" class="headerlink" title="JPEG压缩过程中的DCT"></a>JPEG压缩过程中的DCT</h2><p>在JPEG压缩过程中，经过颜色空间的转换，每一个8X8的图像块，在数据上表现为3个8X8的矩阵，紧接着我们对这三个矩阵做一个二维的DCT转换，二维的DCT转换公式为<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041651961.png"><br>DCT的威力究竟有多大，我们可以做一个实际的测试，比如一个所有数值都一样的矩阵，经过DCT转换后，将所有级数组合成一个新的矩阵<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041654047.png"><br>可以看到，经过DCT转换，矩阵的“能量”被全部集中在左上角上的直流分量F(0,0）上，其他位置都变成了0。<br>在实际的JPEG压缩过程中，由于图像本身的连贯性，一个8X8的图像中的数值一般不会出现大的跳跃，经过DCT转换会有类似的效果，左上角的直流分量保存了一个大的数值，其他分量都接近于0，我们以Lenna左上角第一块图像的Y分量为例，经过变换的矩阵为<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041656718.png"><br>可以看到，数据经过DCT变化后，被明显分成了直流分量和交流分量两部分，为后面的进一步压缩起到了充分的铺垫作用，可以说是整个JPEG中最重要的一步，后面我们会介绍数据量化。</p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> JPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpeg压缩算法(三)：量化</title>
      <link href="/2022/09/04/jpeg-algo-3/"/>
      <url>/2022/09/04/jpeg-algo-3/</url>
      
        <content type="html"><![CDATA[<h1 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h1><p>经过上一节介绍的离散余弦变换，图像数据虽然已经面目全非，但仍然是处于“可逆”的状态，也就是说我们还没有进入“有损”的那一步。这次我们来玩真的，看一下数据中的细节是如何被滤去的。先来考察一下要对付的问题是什么，经过颜色空间转换和离散余弦变换，每一个8X8的图像块都变成了三个8X8的浮点数矩阵，分别表示Y,Cr,Cb数据，比如以其中某个<strong>亮度数据矩阵</strong>举例，它的数据如下<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041701487.png">  </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们的问题是，在可以损失一部分精度的情况下，如何用更少的空间存储这些浮点数？答案是使用量子化（Quantization），简称量化。“量子”这个概念来自于物理学，意思是说连续的能量可以看做是一个个单元体的组合，看起来高端大气，其实很简单，比如游戏中在处理角色面朝方向时，一般并不是使用0到2π这样的浮点数，而是把方向分成16个区间，用0到16这样的整数来表示，这样只用4个bit就足够了。JPEG提供的量子化算法如下：<br>$$<br>B_{ij}&#x3D;round(\frac {G_{i,j}}{Q_{i,j}})<br>$$<br>其中G是我们需要处理的图像矩阵，Q称作量化系数矩阵（Quantization matrices），JPEG算法提供了两张标准的量化系数矩阵，分别用于处理亮度数据Y和色差数据Cr以及Cb。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041704701.png"><br>其中round函数是取整函数(四舍五入)       </p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如上面数据，以左上角的-415.38为例，对应的量子化系数是16，那么round(-415.38&#x2F;16)  &#x3D;round(-25.96125)&#x3D;-26。最终得到的量子化后的结果为<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041707129.png"><br>可以看到，一大部分数据变成了0，这非常有利于后面的压缩存储。这两张神奇的量化表也是有讲究的，还记得我们在第一节中所讲的有损压缩的基本原理吗，有损压缩就是把数据中重要的数据和不重要的数据分开，然后分别处理。DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据时人们根据人眼对不不同频率的敏感程度的差别所积累下的经验制定的，一般来说人眼对于低频的分量必高频分量更加敏感，所以两张量化系数矩阵左上角的数值明显小于右下角区域。在实际的压缩过程中，还可以根据需要在这些系数的基础上再乘以一个系数，以使更多或更少的数据变成0，我们平时使用的图像处理软件在生成jpg文件时，在控制压缩质量的时候，就是控制的这个系数。<br>在进入下一节之前，矩阵的量化还有最后一步要做，就是把量化后的二维矩阵转变成一个一维数组，以方便后面的<strong>霍夫曼压缩</strong>，但在做这个顺序转换时，需要按照一个特定的取值顺序。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209041710811.png"><br>这么做的目的只有一个，就是尽可能把0放在一起，由于0大部分集中在右下角，所以才去这种由左上角到右下角的顺序，经过这种顺序变换，最终矩阵变成一个整数数组   </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-26,-3,0,-3,-2,-6,2,-4,1,-3,0,1,5,,1,2,-1,1,-1,2,0,0,0,0,0,-1,-1,0,0,0,0,…,0,0  </span><br></pre></td></tr></table></figure><p>后面的工作就是对这个数组进行再一次的哈夫曼压缩，已得到最终的压缩数据。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://thecodeway.com/blog/?p=522">https://thecodeway.com/blog/?p=522</a></p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> JPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpeg压缩算法(一)：图像分割+色域空间转换</title>
      <link href="/2022/09/03/jpeg-algo-1/"/>
      <url>/2022/09/03/jpeg-algo-1/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤一：图像分割"><a href="#步骤一：图像分割" class="headerlink" title="步骤一：图像分割"></a>步骤一：图像分割</h1><p>JPEG算法的第一步，图像被分割成大小为8X8的小块，这些小块在整个压缩过程中都是单独被处理的。后面我们会以一张非常经典的图为例，这张图片名字叫做Lenna，据说是世界上第一张JPG图片，这张图片自从诞生之日开始，就和图像处理结下渊源，陪伴了无数理工宅男度过了的一个个不眠之夜，可谓功勋卓著，感兴趣的朋友可以在这里了解到这张图片的故事。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209032221471.png"></p><h1 id="步骤二：颜色空间转换RGB-gt-YCbCr"><a href="#步骤二：颜色空间转换RGB-gt-YCbCr" class="headerlink" title="步骤二：颜色空间转换RGB-&gt;YCbCr"></a>步骤二：颜色空间转换RGB-&gt;YCbCr</h1><p>所谓“颜色空间”，是指表达颜色的数学模型，比如我们常见的“RGB”模型，就是把颜色分解成红绿蓝三种分量，这样一张图片就可以分解成三张灰度图，数学表达上，每一个8X8的图案，可以表达成三个8X8的矩阵，其中的数值的范围一般在[0,255]之间。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209032223260.png"></p><p>不同的颜色模型各有不同的应用场景，例如RGB模型适合于像显示器这样的自发光图案，而在印刷行业，使用油墨打印，图案的颜色是通过在反射光线时产生的，通常使用CMYK模型，而在JPEG压缩算法中，需要把图案转换成为YCbCr模型，这里的Y表示亮度(Luminance)，Cb和Cr分别表示绿色和红色的“色差值”。<br>“色差”这个概念起源于电视行业，最早的电视都是黑白的，那时候传输电视信号只需要传输亮度信号，也就是Y信号即可，彩色电视出现之后，人们在Y信号之外增加了两条色差信号以传输颜色信息，这么做的目的是为了兼容黑白电视机，因为黑白电视只需要处理信号中的Y信号即可。<br>根据三基色原理，人们发现红绿蓝三种颜色所贡献的亮度是不同的，绿色的“亮度”最大，蓝色最暗，设红色所贡献的亮度的份额为KR，蓝色贡献的份额为KB，那么亮度为<br>$$Y&#x3D;K_ {R}\cdot R+(1-K_ {R}-K_ {B})\cdot G+K_ {B}\cdot B$$<br>根据经验，$K_{R}&#x3D;0.299$，$K_{B}&#x3D;0.114$，那么<br>$$Y&#x3D;0.299\cdot R+0.587\cdot G+0.114\cdot B$$<br>蓝色和红色的色差的定义如下<br>$$C_ {b}&#x3D;\frac {1}{2}\cdot \frac {B-Y}{1-K_ {B}}$$<br>$$C_ {r}&#x3D;\frac {1}{2}\cdot \frac {R-Y}{1-K_ {F}}$$<br>最终可以得到RGB转换为YCbCr的数学公式为<br>$$Y &#x3D; 0.299\cdot R+0.5870\cdot G+ 0.114\cdot B$$<br>$$C_ {b}&#x3D;-0.1687\cdot R-0.3313\cdot G+0.5\cdot B$$<br>$$C_{r}&#x3D;0.5\cdot R-0.4187\cdot G-0.0813\cdot B$$<br><strong>有损压缩</strong>首先要做的事情就是“把重要的信息和不重要的信息分开”，YCbCr恰好能做到这一点。对于人眼来说，图像中明暗的变化更容易被感知到，这是由于人眼的构造引起的。视网膜上有两种感光细胞，能够感知亮度变化的视杆细胞，以及能够感知颜色的视锥细胞，由于视杆细胞在数量上远大于视锥细胞，所以我们更容易感知到明暗细节。比如说下面这张图<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202209032232358.png"><br>可以明显看到，亮度图的细节更加丰富。JPEG把图像转换为YCbCr之后，就可以针对数据得重要程度的不同做不同的处理。这就是为什么JPEG使用这种颜色空间的原因。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://thecodeway.com/blog/?p=69">https://thecodeway.com/blog/?p=69</a></p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> JPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpeg算法简介</title>
      <link href="/2022/08/28/jpeg-algo/"/>
      <url>/2022/08/28/jpeg-algo/</url>
      
        <content type="html"><![CDATA[<h1 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h1><p>图片压缩有多重要，可能很多人可能并没有一个直观上的认识，举个例子，一张800X800大小的普通图片，如果未经压缩，大概在1.7MB左右，这个体积如果存放文本文件的话足够保存一部92万字的鸿篇巨著《红楼梦》，现如今互联网上绝大部分图片都使用了JPEG压缩技术，也就是大家使用的jpg文件，通常JPEG文件相对于原始图像,能够得到1&#x2F;8的压缩比，如此高的压缩率是如何做到的呢？<br>JPEG能够获得如此高的压缩比是因为使用了有损压缩技术，所谓有损压缩，就是把原始数据中不重要的部分去掉，以便可以用更小的体积保存，这个原理其实很常见，比如485194.200000000001这个数，如果我们用485194.2来保存，就是一种“有损”的保存方法，因为小数点后面的那个“0.000000000001”属于不重要的部分，所以可以被忽略掉。JPEG整个压缩过程基本上也是遵循这个步骤：  </p><ol><li>把数据分为“重要部分”和“不重要部分”  </li><li>滤掉不重要的部分  </li><li>保存</li></ol><p>特点： 图片尺寸小，清晰度高<br>原理： 删除人眼不易察觉的元素</p><h1 id="工序"><a href="#工序" class="headerlink" title="工序"></a>工序</h1><ol><li><p>色彩空间转换<br>Y 亮度<br>Cb 蓝色色度<br>Cr 红色色度<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/202208282032890.png"></p></li><li><p>色度缩减采样<br>以2x2大小的像素为一个区块，计算每个区块中像素的平均值，并删除重复的信息。然后缩小图像，使得含有一个平均值的由四个像素组成的区块只占一个像素空间，亮度通道Y保持不变。此时，亮度为1，Cb和Cr都缩减为原来的1&#x2F;4。<br>这一步完成以后图像大小缩减为1&#x2F;2。</p></li><li><p>离散余弦变换（DCT）<br>以8x8大小的像素划分成区块，每个8x8的区域都用64张基础图像线性组合而成。<br>DCT无法压缩或者缩小图像。</p></li><li><p>量化<br>DCT变换后的图像除以一个频率举证，这个矩阵左上角为低频数据，人眼感知能力强，所以数值较小；反之右下角频率高，人眼感知能力弱，数值较大。</p></li><li><p>游程编码和哈夫曼编码<br>由左上角之字形列出所有区块中的亮度和色度数值<br>游程编码： 将列表中的0不列出来，只显示他有多少个<br>哈夫曼编码：</p></li></ol><h1 id="jpeg图像重构"><a href="#jpeg图像重构" class="headerlink" title="jpeg图像重构"></a>jpeg图像重构</h1><p>按以上工序反向操作。</p><h1 id="jpeg的缺点"><a href="#jpeg的缺点" class="headerlink" title="jpeg的缺点"></a>jpeg的缺点</h1><p>jpeg适合相机图像但不适合矢量图</p><h1 id="H-264压缩算法（AVC）"><a href="#H-264压缩算法（AVC）" class="headerlink" title="H.264压缩算法（AVC）"></a>H.264压缩算法（AVC）</h1><p>在每一秒视频的30帧视频中提取两个I帧（iframe），然后对其他的29个帧使用预测或者双向预测，只对差异和运动进行编码，同时使用向前解码的帧作为参考。iframe的操作流程类似与jpeg算法。</p><h1 id="入门视频"><a href="#入门视频" class="headerlink" title="入门视频"></a>入门视频</h1><div class="video">            <iframe src="https://www.bilibili.com/video/BV1TZ4y1S7iG?spm_id_from=333.337.search-card.all.click&vd_source=14563ae47f9914f546a18b00439d05d2&t=94.1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://thecodeway.com/blog/?p=69">https://thecodeway.com/blog/?p=69</a></p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> JPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科大讯飞OCR公式识别实现截图获取latex</title>
      <link href="/2022/08/23/latex-ocr/"/>
      <url>/2022/08/23/latex-ocr/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试了一下两个做图片转latex公式的平台，科大讯飞和好未来。科大讯飞每天免费500次，但是识别的不准；好未来识别的准，但只有100次的试用。我还是选择用科大讯飞的，识别错的地方改改就行。</p><p>基于科大讯飞的公式识别接口，实现了调用微信dll文件截图功能，识别后自动保存至剪贴板。</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>讯飞公式识别API： 一天免费500次</li><li>PrScrn.dll：旧版微信的截图dll <a href="https://github.com/callmeLP/latex_ocr/tree/main/xf">下载链接</a>。</li><li>python</li></ul><h1 id="接口申请"><a href="#接口申请" class="headerlink" title="接口申请"></a>接口申请</h1><h2 id="科大讯飞"><a href="#科大讯飞" class="headerlink" title="科大讯飞"></a>科大讯飞</h2><p><a href="https://console.xfyun.cn/">https://console.xfyun.cn/</a></p><h2 id="好未来"><a href="#好未来" class="headerlink" title="好未来"></a>好未来</h2><p><a href="https://ai.100tal.com/">https://ai.100tal.com/</a></p><h1 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h1><p>代码去这里下载：<a href="https://github.com/callmeLP/latex_ocr/tree/main/xf">github代码地址</a>  </p><ul><li><p><code>WebITRTeach.py</code>是科大讯飞官网上的demo，我做了一点儿小修改。现在是传入图片路径，然后向讯飞发post请求。<br>  发送的原理就是把图片转成base64格式的数据，填到body里去。</p></li><li><p><code>main.py</code>主要是实现截图、截图时隐藏窗口、将结果复制到剪切板等操作。</p><ol><li>截图 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;RUNDLL32.EXE PrScrn.dll PrScrn&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>截图时隐藏窗口<br> 调用ctype获取窗口句柄和windll <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window_handle = ctypes.windll.kernel32.GetConsoleWindow()</span><br><span class="line"><span class="comment"># 0：隐藏；6：最小化</span></span><br><span class="line"><span class="comment"># 1：显示；3：最大化</span></span><br><span class="line">ctypes.windll.user32.ShowWindow(window_handle, <span class="number">0</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">ctypes.windll.user32.ShowWindow(window_handle, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>从剪贴板中读取图片 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = ImageGrab.grabclipboard()</span><br></pre></td></tr></table></figure></li><li>结果复制到剪切板 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyperclip.copy(content)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h1><p>修改<code>WebITRTeach.py</code>文件中的<code>APPID</code> <code>Secret</code> <code>APIKey</code>三个参数（自己去平台上申请）,然后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/latex_ocr.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github的.gitignore忽略文件</title>
      <link href="/2022/08/22/github-ignore/"/>
      <url>/2022/08/22/github-ignore/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天开学第一天，写了一个调api OCR公式转latex的代码，我自己的帐号密钥文件需要隐藏起来。我使用的是不把git里的这个密钥文件上传到github，下面记录一下方法。</p><p><strong>重要！重要！重要！重要的事情说三遍！大家一定要养成在项目开始就创建 .gitignore 文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><h1 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h1><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。    </p><h2 id="gitignore-文件创建"><a href="#gitignore-文件创建" class="headerlink" title=".gitignore 文件创建"></a>.gitignore 文件创建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch  .gitignore     #创建gitignore隱藏文件  </span><br><span class="line">vim    .gitignore     #编辑文件，加入指定文件</span><br></pre></td></tr></table></figure><p>示例：这个文件每一行保存了一个匹配的规则  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><p>文件.gitignore的格式规范：<br>    1. #为注释<br>    2. 可以使用shell所使用的正则表达式来进行模式匹配<br>    3. 匹配模式最后跟”&#x2F;“说明要忽略的是目录<br>    4. 使用！取反（例如目录中包含  test.a，并且gitignore文件中包含  *.[oa]，如果在文件中加入 ！test.a   表明忽略除test.a文件以外的后缀名为.a或者.o的文件）</p><h1 id="如果已经push了怎么办"><a href="#如果已经push了怎么办" class="headerlink" title="如果已经push了怎么办"></a>如果已经push了怎么办</h1><p>有时候在项目开发过程中，想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态） </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -r --cached 文件/文件夹名字</span><br></pre></td></tr></table></figure><p>去掉已经托管的文件或者文件夹，然后提交即可。</p><h1 id="gitignoreglobal全局忽略文件"><a href="#gitignoreglobal全局忽略文件" class="headerlink" title="gitignoreglobal全局忽略文件"></a>gitignoreglobal全局忽略文件</h1><p>另外 git 提供了一个全局的 .gitignore 相当于以后每一个仓库里符合规则的都不提交，你可以在你的用户目录下创建 ~&#x2F;.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。</p><p>需要执行 <code>git config --global core.excludesfile ~/.gitignoreglobal</code>来使得它生效。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黄金正弦算法</title>
      <link href="/2022/08/21/golden-sinAlgo/"/>
      <url>/2022/08/21/golden-sinAlgo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>黄金正弦算法(Gold-SA)是 Tanyildizi 等 于2017 年提出的一种新型元启发式优化算法，其灵感来源于正弦函数单位圆内扫描类似于待优化问题解的空间搜索，并通过黄金分割率缩小搜索空间以逼近算法最优解。与传统元启发式优化算法相比，Gold-SA 算法具有原理简单、设置参数少、寻优能力强等特点。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>与其他基于种群的优化算法一样，Gold-SA 算法也从随机生成的种群开始。Gold-SA 算法初始种群旨在通过随机生成每个维度的均匀分布来更好地扫描搜索空间。<br>$$<br>V_{i}&#x3D;rand*(ub-lb)+lb\tag{1}<br>$$<br>式中$V_{i}$是第$i$个个体的初始值$ub$,$lb$为搜索空间的上下限。  </p><h2 id="黄金分割系数"><a href="#黄金分割系数" class="headerlink" title="黄金分割系数"></a>黄金分割系数</h2><p>Gold-SA 算法在位置更新过程中引入黄金分割系数 $x_{1}$ 和 $x_{2}$使“搜索”和“开发”达到良好的平衡，这些系数缩小了搜索空间引领个体趋近最优值。<br>$$<br>x_{1}&#x3D;a*(1-t)+b<em>t<br>$$<br>$$<br>x_{2}&#x3D;a</em>t+b*(1-t)<br>$$<br>式中$a$、$b$为黄金分割比率搜索初始值,一般$a&#x3D; -\pi$,$b&#x3D;\pi$,$t$为黄金分比率。$t &#x3D; (\sqrt{5}-1)&#x2F;2$  </p><h2 id="位置更新"><a href="#位置更新" class="headerlink" title="位置更新"></a>位置更新</h2><p>随着迭代次数的增加，Gold-SA算法通过下式进行位置更新<br>$$<br>\mathrm{V}<em>{\mathrm{i}}^{\mathrm{t}+1}&#x3D;\mathrm{V}</em>{\mathrm{i}}^{\mathrm{t}}|\sin (\mathrm{r} 1)|-\mathrm{r}<em>{2} \sin \left(\mathrm{r}</em>{1}\right)\left|\mathrm{x}<em>{1} \mathrm{D}</em>{\mathrm{i}}^{\mathrm{t}}-\mathrm{x}<em>{2} \mathrm{~V}</em>{\mathrm{i}}^{\mathrm{t}}\right|<br>$$</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ol><li><p>初始化参数，设置黄金正弦相关参数</p></li><li><p>计算适应度值</p></li><li><p>计算黄金分割率</p></li><li><p>根据位置更新公式，更新位置。</p></li><li><p>计算适应度值，并更新最优位置，记录最优位置。</p></li><li><p>判断是否达到迭代结束条件，如果达到则输出最后结果，否则重复1-6.</p></li></ol><h1 id="算法结果"><a href="#算法结果" class="headerlink" title="算法结果"></a>算法结果</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220821212225.png">  </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] TANYILDIZI E，DEMIＲ G. Golden sine algorithm: a novel math inspired algorithm［J］. Advances in Electrical and Computer Engineering，2017，17(2): 71 －79.</p><p>[2] 周有荣,李娜,周发辉.黄金正弦算法在水文地质参数优化中的应用[J].人民珠江,2020,41(06):117-120+128.</p><p>[3] <a href="https://blog.csdn.net/u011835903/article/details/111699194">https://blog.csdn.net/u011835903/article/details/111699194</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混沌映射</title>
      <link href="/2022/08/16/chaotic-mapping/"/>
      <url>/2022/08/16/chaotic-mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在优化领域，混沌映射可以用于替代伪随机数生成器，生成 0 到 1 之间的混沌数。经过实验证明，利用混沌序列进行种群初始化、选择、交叉和变异等操作会影响算法的整个过程，而且常常能取得比伪随机数更好的效果。</p><h1 id="混沌映射特征"><a href="#混沌映射特征" class="headerlink" title="混沌映射特征"></a>混沌映射特征</h1><p>混沌映射被用于生成混沌序列，这是一种由简单的确定性系统产生的随机性序列。一般混沌序列具有以下主要特征：  </p><ol><li>非线性；</li><li>对初值的敏感依赖性；</li><li>遍历性；</li><li>随机性；</li><li>奇异吸引子（混沌吸引子）；</li><li>分数维持性；</li><li>整体稳定局部不稳定；</li><li>长期不可预测性；</li><li>轨道不稳定性及分叉；</li><li>普适性和Feigenbaum常数。</li></ol><h1 id="常见分类"><a href="#常见分类" class="headerlink" title="常见分类"></a>常见分类</h1><ol><li><p>Logistic 映射，又称虫口映射<br> $$z_{k+1}&#x3D;\mu z_{k}\left(1-z_{k}\right)$$<br> 其中，$z_{0} \notin{0,0.25,0.5,0.75,1.0} \quad \mu \in[0,4]$</p></li><li><p>PWLCM映射<br> $$z_{k+1}&#x3D;\left{\begin{array}{ll}z_{k} &#x2F; p, &amp; z_{k} \in(0, p) \ \left(1-z_{k}\right)(1-p), &amp; z_{k} \in[p, 1)\end{array} ;\right.$$</p></li><li><p>Singer映射<br> $$z_{k+1}&#x3D;\mu\left(7.86 z_{k}-23.31 z_{k}^{2}+28.75 z_{k}^{3}-13.302875 z_{k}^{4}\right)$$<br> 其中，当 $\mu \in[0.9,1.08]$ 时，Singer 映射具有混沌行为。</p></li><li><p>Sine 映射<br> $$z_{k+1}&#x3D;\frac{4}{a} \sin \left(\pi z_{k}\right)$$<br> Sine 映射是一种单峰映射，并且值域为 $[-1, 1]$, 其中 $a \in (0,4]$</p></li><li><p>Gussian映射<br> $$z_{k+1}&#x3D;\left{\begin{array}{ll}0, &amp; z_{k}&#x3D;0 \ \bmod \left(\mu &#x2F; z_{k}, 1\right), &amp; z_{k} \neq 0\end{array} ;\right.$$</p></li><li><p>Tent 映射，又称帐篷映射<br> $$z_{k+1}&#x3D;\left{\begin{array}{ll}z_{k}&#x2F;(1-\lambda), &amp; z_{k} \in (0, 1-\lambda] \ (z_{k}-1+\lambda)&#x2F;\lambda, &amp; z_{k} \in (1-\lambda, 0]\end{array} ;\right.$$</p></li><li><p>Chebyshev 映射<br> $$z_{k+1}&#x3D;\cos(\phi \cos^{-1}z_{k})$$</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>&lt;<a href="https://www.cnblogs.com/BaobMa/p/15960929">https://www.cnblogs.com/BaobMa/p/15960929</a>.<br>html&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲸鱼算法</title>
      <link href="/2022/08/14/whale-algo/"/>
      <url>/2022/08/14/whale-algo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鲸鱼算法（Whale Optimization Algorithm）是根据鲸鱼围捕猎物的行为而提出的算法。鲸鱼是一种群居的哺乳动物，在捕猎时它们也会相互合作对猎物进行驱赶和围捕。<br>鲸鱼算法中，每个鲸鱼的位置代表了一个可行解。在鲸鱼群捕猎过程中，每只鲸鱼有两种行为，一种是包围猎物，所有的鲸鱼都向着其他鲸鱼前进；另一种是汽包网，鲸鱼环形游动喷出气泡来驱赶猎物。在每一代的游动中，鲸鱼们会随机选择这两种行为来进行捕猎。在鲸鱼进行包围猎物的行为中，鲸鱼将会随机选择是向着最优位置的鲸鱼游去还是随机选择一只鲸鱼作为自己的目标，并向其靠近。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>在海洋活动中，座头鲸有着一种特殊的狩猎方法，这种觅食行为称为bubble-net 捕食策略，其狩猎行为如图所示。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815102849.png"></p><h2 id="包围猎物"><a href="#包围猎物" class="headerlink" title="包围猎物"></a>包围猎物</h2><p>座头鲸在狩猎时要包围猎物，为了描述这种行为，Mirjalili 提出了下面的数学模型：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815104759.png"><br>式中：$t$ 是当前迭代次数；$A$ 和 $C$ 为表示系数，$X^{*}(t)$ 表示目前为止最好的鲸鱼位置向量，$X(t)$ 表示当前鲸鱼的位置向量，$A$ 和 $C$ 由下式可得到<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815105230.png"><br>其中，$r_{1}$和$r_{2}$是(0,1)中的随机数，$a$ 的值从 2到 0 线性下降，$t$  表示当前的迭代次数，$T_{max}$ 为最大迭代次数。</p><h2 id="狩猎行为"><a href="#狩猎行为" class="headerlink" title="狩猎行为"></a>狩猎行为</h2><p>根据座头鲸的狩猎行为，它是以螺旋运动游向猎物，故狩猎行为的数学模型如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815111640.png"><br>其中, $D_{p} &#x3D; |X^{<em>}(t)−X(t)|$ 表示鲸鱼和猎物之间的距离，$X^{</em>}(t)$ 表示目前为止最好的位置向量，$b$ 是一个常数，用来定义螺线的形状， $l$ 是 $(−1,1)$ 中的随机数。值得注意的是，鲸鱼以螺旋形状游向猎物的同时还要收缩包围圈。因此，在这种同步行为模型中，假设有 $P_{i}$ 的概率选择收缩包围机制和 $1−P_{i}$ 的概率选择螺旋模型来更新鲸鱼的位置，其数学模型如下:<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815112050.png"><br>攻击猎物时，在数学模型上靠近猎物设定了减小 $a$ 的值，这样 $A$ 的波动范围也随$a$ 下降。在迭代过程中当$a$的值从2到0下降时，$A$ 是在$[−a,a]$内的随机值，当 $A$ 的值在[−1,1]内时，鲸鱼的下一个位置可以是它现在的位置和猎物的位置之间的任意位置，算法设定当 $A&lt;1$ 时，鲸鱼向猎物发起攻击。</p><h2 id="搜索猎物"><a href="#搜索猎物" class="headerlink" title="搜索猎物"></a>搜索猎物</h2><p>在搜索猎物时，其数学模型如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815112309.png"><br>其中，$X_{rand}$是随机选择的鲸鱼位置向量，算法设定当 $A≥1$ 时，随机选择一个搜索代理，根据随机选择的鲸鱼位置来更新其他鲸鱼的位置，迫使鲸鱼偏离猎物，借此找到一个更合适的猎物，这样可以加强算法的勘探能力使 WOA 算法能够进行全局搜索.</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>（1）初始化参数：即鲸鱼种群规模大小 $SN$，最大迭代次数 $T_{max}$;<br>（2）算法初始化鲸鱼种群的位置；<br>（3）计算每一头鲸鱼相应的适应度值，根据适应度值的大小排序，并选取 $SN$ 个作为初始种群；<br>（4）计算出 $SN$ 个个体适应度值的大小，找出适应度值最小的个体位置作为最优位置；<br>（5）更新下一代的位置；<br>（6）若达到终止条件，则输出最优个体，即算法找到的最优解；否则，返回步骤（4）。  </p><h1 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h1><p><a href="https://github.com/callmeLP/Optimization-Algorithm/tree/main/WOA">https://github.com/callmeLP/Optimization-Algorithm/tree/main/WOA</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Seyedali Mirjalili,Andrew Lewis. The Whale Optimization Algorithm[J]. Advances in Engineering Software,2016,95.<br><a href="https://www.jianshu.com/p/916a1dcac282">https://www.jianshu.com/p/916a1dcac282</a><br><a href="https://blog.csdn.net/u011835903/article/details/107559167">https://blog.csdn.net/u011835903/article/details/107559167</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分进化算法</title>
      <link href="/2022/08/12/Differential-Evolution/"/>
      <url>/2022/08/12/Differential-Evolution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>差分进化算法(Differential Evolution Algorithm，DE)是一种高效的全局优化算法。它也是基于群体的启发式搜索算法，群中的每个个体对应一个解向量。差分进化算法的进化流程则与遗传算法非常类似，都包括变异、杂交和选择操作，但这些操作的具体定义与遗传算法有所不同。</p><h1 id="差分进化算法"><a href="#差分进化算法" class="headerlink" title="差分进化算法"></a>差分进化算法</h1><p>差分进化算法和遗传算法有些相似，但是比遗传算法简单好实现，但是差分进化算法的变种，或者说变形有很多，大家可以根据具体情况选择。<br>差分进化算法也是在现有的解上面，根据一定的办法选择几个解，根据变异公式把这几个解融合成一个变异解，这个过程称为变异；把第i个变异解和第i个旧解的每个参数，跟据一定概率选择选择新解或者旧解的值，称为交叉，形成交叉解；把第i个交叉解和第i个旧解比较，选择较优的解保存作为下一次循环的解，这也是差分进化算法最不同于遗传算法的地方。</p><h2 id="差分进化算法流程"><a href="#差分进化算法流程" class="headerlink" title="差分进化算法流程"></a>差分进化算法流程</h2><ol><li><p>初始化<br>随机初始化数目为NP的D维参数向量 $x$ ，$x(i)$ 表示第i个解，每个解参数可以表示为 $x(i,j)$ ，$i&#x3D;1,2,…,NP,j&#x3D;1,2,…,D$<br>解数目NP根据情况选择，一般选取[50,200]。</p></li><li><p>变异<br>对于每个解向量$x(i)$，对应的变异向量$v$可以表示为：<br>$$<br>\begin{aligned}<br>v(i)&#x3D;x(r_{0})+F*(x(r_{1})-x(r_{2}))<br>\end{aligned}<br>$$<br>$r0,r1,r2$为属于[1,…,NP]的三个随机数，并且 $i,r0,r1,r2$ 都不相同，这要求NP必须大于等于4。<br>变异算子 $F$ 取值范围为[0,2]，F过小可能陷入局部最优，F过大则不容易收敛，一般去[0.4,1]居多。<br>边界问题：如果变异以后的值$v(i,j)$超出了边界，可以随机再选择一个数，或者直接去边界值都是可以的。 </p></li><li><p>交叉<br>接下来求交叉向量u，对于u的每个值，有：<br>如果 $rand()&lt;&#x3D;CR: u(i,j)&#x3D;v(i,j)$<br>如果 $rand()&gt;CR : u(i,j)&#x3D;x(i,j)$<br>$rand()$是一个随机数，CR是交叉算子，[0,1]，用来控制选择变异向量值还是原来的向量值。  </p></li><li><p>选择<br>把交叉向量和原向量对比，选择较优的那个，这里交叉向量之和对应的原向量对比，也就是对比$u(i)$和$x(i)$哪个更优，就选择哪个作为新的解向量，更新向量$x$，进行下一步。  </p></li><li><p>终止条件<br>当最后的解满足条件，或者遍历次数达到最大，则结束，否则重复2到4。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>差分进化算法比较简答，容易实现，可修改的地方也不少，比如变异向量选择上面，可以选择x(best)+F*(x(r1)-x(r2))，x(best)是全局最优解。甚至说F*(…)里面的随机参数，可以是四个六个，这些都是差分进化算法的变形。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>题目：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/1.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">作者:LP</span></span><br><span class="line"><span class="string">时间:2022年4月24日</span></span><br><span class="line"><span class="string">题目：差分进化算法</span></span><br><span class="line"><span class="string">参考:https://blog.csdn.net/Goldboys/article/details/112913122</span></span><br><span class="line"><span class="string">题目:f ( x , y ) = 3 c o s ( x y ) + x + y </span></span><br><span class="line"><span class="string">        x属于[-4, 4] </span></span><br><span class="line"><span class="string">        y属于[-4, 4] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">参考使用面向过程思想编写 本人使用面向对象思想实现</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_fitness</span>(<span class="params">x</span>):</span><br><span class="line">    value = <span class="number">3</span>*np.cos(x[<span class="number">0</span>] * x[<span class="number">1</span>] + x[<span class="number">0</span>] + x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DE</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化种群</span></span><br><span class="line"><span class="string">    参数: time 迭代次数</span></span><br><span class="line"><span class="string">          F    变异算子</span></span><br><span class="line"><span class="string">          CR   交叉算子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, time, F, CR</span>):</span><br><span class="line">        self.X = <span class="number">0</span>      <span class="comment"># 最终迭代后的最优变量x</span></span><br><span class="line">        self.Y = <span class="number">0</span>      <span class="comment"># 最终迭代后的最优变量y</span></span><br><span class="line">        self.time = time</span><br><span class="line">        self.F = F</span><br><span class="line">        self.CR = CR</span><br><span class="line">        self.Ob=[]  <span class="comment">#种群列表中的适应度</span></span><br><span class="line">        self.trace = []  <span class="comment">#最小适应度</span></span><br><span class="line">        self.x = np.zeros((<span class="number">2</span>,<span class="number">50</span>))</span><br><span class="line">        self.v = np.zeros((<span class="number">2</span>,<span class="number">50</span>))   <span class="comment">#变异种群</span></span><br><span class="line">        self.u = np.zeros((<span class="number">2</span>,<span class="number">50</span>))   <span class="comment">#选择种群</span></span><br><span class="line">        self.x = np.random.rand(<span class="number">2</span>, <span class="number">50</span>) * <span class="number">8</span> - <span class="number">4</span>  <span class="comment">#将随机取值限制在区间范围内</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">            self.Ob.append(func_fitness(self.x[:,[m]]))</span><br><span class="line">        self.trace.append(<span class="built_in">min</span>(self.Ob))</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    变异操作：随机选择三个不相同的值使用差分公式</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">variation</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            r1=random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r1==m):</span><br><span class="line">                r1 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            r2 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r2 == m) <span class="keyword">and</span> (r2 == r1):</span><br><span class="line">                r2 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            r3 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r3 == m) <span class="keyword">and</span> (r3 == r2) <span class="keyword">and</span> (r3 == r1):</span><br><span class="line">                r3 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#差分</span></span><br><span class="line">            self.v[:,m] = self.x[:,r1]+self.F*(self.x[:,r2]-self.x[:,r3])</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    交叉操作：概率小于CR值时，将变异种群的行向量赋给选择种群，否则使用初始化的种群</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cross</span>(<span class="params">self</span>):</span><br><span class="line">        r=np.random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            cr=np.random.rand()</span><br><span class="line">            <span class="keyword">if</span> (cr &lt;= self.CR <span class="keyword">and</span> n == r):</span><br><span class="line">                self.u[n, :] = self.v[n, :]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.u[n, :] = self.x[n, :]</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    边界条件处理:交叉操作后，将选择种群中的值限制在取值范围内</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">                <span class="keyword">if</span> self.u[n,m] &lt; -<span class="number">4</span>:</span><br><span class="line">                    self.u[n,m] = -<span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> self.u[n,m] &gt; <span class="number">4</span>:</span><br><span class="line">                    self.u[n,m] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获得索引</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">self, Ob, sort_Ob</span>):</span><br><span class="line">        sort_Ob_index=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(Ob)):</span><br><span class="line">            qt=Ob.index(sort_Ob[i])</span><br><span class="line">            sort_Ob_index.append(qt)</span><br><span class="line">        <span class="keyword">return</span>  sort_Ob_index</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    选择操作:对选择矩阵排序</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">self</span>):</span><br><span class="line">        Ob1=[]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            Ob1.append(func_fitness(self.u[:,m]))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> Ob1[m] &lt; self.Ob[m]:</span><br><span class="line">                self.x[:,m] = self.u[:,m]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            self.Ob[m] = func_fitness(self.x[:,m])</span><br><span class="line">        self.trace.append(<span class="built_in">min</span>(self.Ob))</span><br><span class="line">        sort_Ob = <span class="built_in">sorted</span>(self.Ob)</span><br><span class="line">        sort_Ob_index = self.get_index(self.Ob,sort_Ob)</span><br><span class="line">        self.x=self.x[:,sort_Ob_index]</span><br><span class="line">        self.X=self.x[:,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(self.Ob)</span></span><br><span class="line">        self.Y=<span class="built_in">min</span>(self.Ob)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    循环次数：主循环，按照循环次数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main_loop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(self.time):</span><br><span class="line">            self.variation()</span><br><span class="line">            self.cross()</span><br><span class="line">            self.set_bound()</span><br><span class="line">            self.select()</span><br><span class="line">            <span class="built_in">print</span>(self.X, self.Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cout = DE(<span class="number">100</span>, <span class="number">0.9</span>, <span class="number">0.5</span>)</span><br><span class="line">    cout.main_loop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇优化算法</title>
      <link href="/2022/08/09/snake-optimization/"/>
      <url>/2022/08/09/snake-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>蛇优化(Snake Optimizer, SO)[1]是Hashim, F. A.和 Hussien, A. G两位教授于2022年提出的优化算法，其算法灵感来蛇的觅食和繁殖行为和模式。</p><h1 id="蛇优化算法"><a href="#蛇优化算法" class="headerlink" title="蛇优化算法"></a>蛇优化算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>雄性蛇和雌性蛇之间交配的发生受到某些因素的影响。蛇在春末和初夏交配，那时温度低。但交配过程不仅取决于温度，还取决于食物的充足性。如果<strong>温度低</strong>，<strong>食物充足</strong>;雄性蛇会互相争斗，以吸引雌性的注意力。雌性有权决定是否交配。如果发生交配，雌性开始在巢穴或洞穴中产卵，一旦卵出现，它就会离开。</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>与所有元启发式算法一样，SO 首先生成均匀分布的随机种群，以便能够开始优化算法过程。初始化公式如下：<br>$$X_{i}&#x3D;X_{\min }+r \times\left(X_{\max }-X_{\min }\right)$$<br>其中，$X_{i}$ 为第i个位置的解,$r \in[0,1]$，$X_{max}$和$X_{min}$分别为待解决问题的上下界。此后，将初始化的种群分为雄性和雌性两个部分，原文中雄雌比例为1:1。</p><p>SO的探索和开发阶段主要受温度 $Temp$ 和食物量 $Q$ 的影响:<br>$$T e m p&#x3D;\exp (-t &#x2F; T)$$<br>$$Q&#x3D;c_{1} * \exp (t-T &#x2F; T)$$<br>其中 $t$ 代表当前迭代， $T$ 代表最大迭代次数，$c_{1} &#x3D; 0.5$ </p><h3 id="探索阶段"><a href="#探索阶段" class="headerlink" title="探索阶段"></a>探索阶段</h3><p>当 $Q&lt;0.25$ （0.25为原文规定的阈值）SO通过择任何随机位置来搜索食物并更新它们相对于它的位置，即探索阶段，随机搜索公式为:<br>$$<br>  雄性：X_ {i}^ {m}  &#x3D;  X_ {rand}^ {m}  (t)  \pm     c_ {2}    \times     A_ {m}    \times   ((  X_ {\max }  -  X_ {\min }  )  \times   rand+  X_ {\min }  )<br>$$<br>$$<br>   雌性： X_{i}^{f}&#x3D;X_{rand}^{f}(t)\pm c_{2}\times A_{f}\times ((X_{\max}-X_{\min})\times rand+X_{\min})<br>$$<br>其中$X_ {i}^ {m}$和$X_ {i}^ {f}$是雄性和雌性SO位置，$X_{rand}^{m}(t)$和$X_{rand}^{f}(t)$是随机SO位置，$c_{2} &#x3D; 0.05$, $r \in [0,1]$, $A_{m}$ 和 $A_{f}$ 为雄性和雌性SO寻找食物的能力，公式如下：<br>$$<br>雄性：A_{m}&#x3D;exp(-f_{rand}^{m}&#x2F;f_{i}^{m})<br>$$<br>$$<br>雌性：A_{f}&#x3D;exp(-f_{rand}^{f}&#x2F;f_{i}^{f})<br>$$<br>其中$f_{rand}^{m}$是$X_{rand}^{m}$的适应度,$f_{i}^{m}$是$X_{i}^{m}$的适应度，雌性同理。</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>SO的开发阶段相对复杂，分为3种模式——靠近猎物(食物)模式、战斗模式、交配模式，3种模式同时受温度 $Temp$ 和食物量 $Q$ 的影响，这是与探索模式的不同之处。</p><h4 id="靠近猎物-食物-模式"><a href="#靠近猎物-食物-模式" class="headerlink" title="靠近猎物(食物)模式"></a>靠近猎物(食物)模式</h4><p>当 $Q&gt;0.25$ 且 $Temp&gt;0.6$，SO移动到食物上，其公式为：<br>$$<br>X_{i,j}(t+1)&#x3D;X_{food}\pm c_{3}\times temp\times rand\times(X_{food}-X_{i,j}(t))<br>$$<br>其中，$X_{i,j}$是整个SO的种群（雌雄），$X_{food}$为全局最优位置，$c_{3}&#x3D;2$</p><h4 id="战斗-x2F-交配模式"><a href="#战斗-x2F-交配模式" class="headerlink" title="战斗&#x2F;交配模式"></a>战斗&#x2F;交配模式</h4><p>当 $Temp\leq0.6$ 时，蛇将处于战斗模式或交配模式。</p><ol><li><p>战斗模式<br> $$<br> X_{i}^{m}(t+1)&#x3D;X_{i}^{m}(t)\pm c_{3}\times FM\times rand\times(X_{best}^{f}-X_{i}^{m}(t))<br> $$<br> $$<br> X_{i}^{f}(t+1)&#x3D;X_{i}^{f}(t)\pm c_{3}\times FF\times rand\times(X_{best}^{m}-X_{i}^{f}(t))<br> $$<br> 其中 $X_{i}^{m}和X_{i}^{f}$ 为雄雌性SO位置，$FM和FF$ 为雄雌性战斗值， $X_{best}^{f}和X_{best}^{m}$ 为雌雄性SO最优位置。$FM和FF$分别表示为：<br> $$<br> FM&#x3D;exp(-f_{best}^{f}&#x2F;f_{i})<br> $$<br> $$<br> FF&#x3D;exp(-f_{best}^{m}&#x2F;f_{i})<br> $$<br> 其中$-f_{best}^{f}和-f_{best}^{m}$分别为最佳雌性和雄性SO适应度值，$f_{i}$为SO的代理位置。</p></li><li><p>交配模式<br> $$<br> X_{i}^{m}(t+1)&#x3D;X_{i}^{m}(t)\pm c_{3}\times M_{m}\times rand\times(Q\times X_{i}^{f}(t)-X_{i}^{m}(t))<br> $$<br> $$<br> X_{i}^{f}(t+1)&#x3D;X_{i}^{f}(t)\pm c_{3}\times M_{f}\times rand\times(Q\times X_{i}^{m}(t)-X_{i}^{f}(t))<br> $$<br> 其中 $X_{i}^{m}$ 和 $X_{i}^{f}$ 分别代表雌性和雄性的SO位置， $M_{m}$ 和 $M_{f}$ 分别代表雄性和雌性SO交配能力，表示如下：<br> $$<br> M_{m}&#x3D;exp(-f_{i}^{f}&#x2F;f_{i}^{m})<br> $$<br> $$<br> M_{f}&#x3D;exp(-f_{i}^{m}&#x2F;f_{i}^{f})<br> $$<br> 其中 $-f_{i}^{f}$ 和 $-f_{i}^{m}$ 分别表示SO的雌性和雄性搜索代理。如果有蛇蛋孵化的话（把最差的<strong>初始化</strong>，重开），则选择最差的雄性和雌性SO进行替换。</p></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>原文matlab链接：<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/106465-snake-optimizer">Snake Optimizer</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/468777899">https://zhuanlan.zhihu.com/p/468777899</a><br>Hashim, F. A., &amp; Hussien, A. G. (2022). Snake Optimizer: A novel meta-heuristic optimization algorithm.Knowledge-Based Systems, 108320.<a href="https://www.sciencedirect.com/science/article/pii/S0950705122001150">论文跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法</title>
      <link href="/2022/08/09/Particle-Swarm-optimization/"/>
      <url>/2022/08/09/Particle-Swarm-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h1><p>粒子群算法，也称粒子群优化算法或鸟群觅食算法（Particle Swarm Optimization），缩写为PSO，是由J. Kennedy和R. C. Eberhart等开发的一种新的进化算法(Evolutionary Algorithm -EA)[1]。PSO算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”(Crossover)和“变异”(Mutation)操作，它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。在 PSO 算法中，将鸟群中的个体称为“粒子”，可行域上的一个点代表食物源，即是个体(粒子)位置，也是所要优化问题的一个潜在解。在可行域中创建 N 个粒子，每个粒子的特征用位置、速度和适应度值表示。每个粒子在可行域中运动并计算得到适应度值，根据个体适应度最好值与群体适应度最好值更新个体位置，从而达到优化的目的[2]。该文首先介绍了标准粒子群算法的基本工作原理和算法迭代步骤，然后分别介绍了现今对粒子群算法的不同改进方法和算法在现实生活中的实际应用。在文章的结论中给出了粒子群算法下一步的研究方向。</p><h2 id="标准粒子群算法"><a href="#标准粒子群算法" class="headerlink" title="标准粒子群算法"></a>标准粒子群算法</h2><p>与其他的基于群体智能的算法相似，粒子群优化算法也是通过群体中不同粒子之间的相互合作和相互竞争来实现在寻优空间中的搜索过程以找到所求问题的最优位置。粒子群算法首先随机的初始化一群均匀分布在给定的寻优空间中的粒子(种群规模一般为30)，然后所有的粒子根据两个极值来更新自身的速度：一个是个体极值( $pbest$ )；另一个是群体极值($gbest$)。目前广泛使用的标准粒子群算法的数学描述为：设粒子群中粒子的总数为 popsize，粒子的维数为m，算法的终止条件(即最大迭代次数)为maxiter，第i个粒子在t时刻的飞行速度和在搜索空间中的位置分别为 $v_{i}(t)&#x3D;[v_{i1}(t),v_{i2}(t),\cdots,v_{im}(t)]^T$, $x_{i}(t)&#x3D;[x_{i1}(t),x_{i2}(t),\cdots,x_{im}(t)]^T$,粒子在t时刻的个体极值和群体极值分别为 $pbest_{i}(t)&#x3D;[p_{i1}(t),p_{i2}(t),\cdots,p_{im}(t)]^T$, $gbest_{i}(t)&#x3D;[g_{1},g_{2},\cdots,g_{m}]^T$ 所有的粒子按照如下的更新方式在搜索空间中飞行以找到最优解。<br>$$<br>\begin{aligned}<br>v_{i+1}(t+1)&#x3D;wv_{i}(t)+c_{1}r_{1}(pbest_{i}(t)-x_{i}(t))+c_{2}r_{2}(gbest-x_{i}(t))<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>x_{i+1}(t+1) &#x3D; x_{i}(t)+v_{i+1}(t+1)<br>\end{aligned}<br>$$<br>其中，$ω$ 为惯性权重系数，决定了上次迭代速度保留的多少。它是粒子群算法的重要参数之一。在粒子群算法中，可以通过调节它的大小来平衡算法的全局搜索和局部搜索的能力。研究分析表明，在粒子群算法的算法初期，选择较大的惯性权重值可以使得算法有很强的全局搜索能力；而在粒子群算法的算法后期选择较小的惯性权重值可以使得粒子逐渐收敛到全局最优。因此，在很多改进的粒子群算法中，惯性权重采用了线性递减的方式进行更新。 $c1$ ， $c2$ 为算法的学习因子，它们分别影响着粒子的“自我学习”能力和“社会学习”能力。一般认为，设置较大的 $c1$ ，会使得所有粒子过多的在局部范围内徘徊，不利于算法的全局搜索；而设置较大的 $c2$ ，则会使得粒子过早的陷入局部极值，降低解的精度。 $r1$ 和 $r2$ 是介于[0,1]之间的随机数。标准粒子群算法的流程可以描述如下。<br>(1)设置种群规模、变量范围、惯性权重、学习因子等参数，并随机的初始化一群均匀分布在给定的寻优空间中的粒子(包含速度和位置信息)。<br>(2)计算群体中各个粒子的适应度值(即函数值)。设置第 $i$ 个粒子的适应度值为它的当前个体极值 $pbest_{i}$，所有粒子中的最好粒子设置为群体的全体极值 $gbest$。<br>(3)根据公式(1)、(2)更新每个粒子的速度和位置。<br>(4)对所有粒子，将其当前的函数值与它以前 找到过的最好位 置进行比较，如果当前位置较好，则将个体最优位置 $pbest_{i}$ 设置为这个粒子的位置，然后再对群体的全局极值 $gbest$ 更新。<br>(5)判断给定的终止条件是否满足。若满足终止条件，停止搜索，输出需要的结果；否则，返回(3)继续搜索。  </p><h1 id="应用研究"><a href="#应用研究" class="headerlink" title="应用研究"></a>应用研究</h1><p>从最初求解一些稍微简单的问题到更为复杂的问题，其发展趋势主要表现在：[3]<br>（1）PSO用于求解有约束的优化问题：2008年，刘伟等人基于参数方程利用粒子群算法求解含有等式约束的优化问题；2007年，曹春红等人利用粒子群算法求解几何约束问题；2008年，王金华等人利用粒子群算法求解约束离散优化问题；同年，魏静菅等基于模糊利用粒子群算法求解约束优化问题。<br>（2）PSO用于随机优化问题的求解：2006年，赵培忻等人利用粒子群算法求解随机装卸工问题；2007年，王芳等利用粒子群算法求解随机需求车辆路径问题；同年，李红梅等人研究了基于量子行为利用粒子群算法求解随机规划问题；陆琳，谭清美等人进行了利用粒子群算法求解随机需求VRP问题的研究。<br>（3）PSO用于最优控制问题的求解：孙凯等利用粒子群优化算法求解航天器太阳帆板伸展过程中，航天器姿态运动的最优控制问题；厉虹、张冰运用粒子群算法在线优化对模糊控制器的量化因子，获得平衡控制器参数的最优值；关圣涛等提出一种基于粒子群优化算法的非线性模型预测控制，在滚动优化部分应用粒子群优化算法求解预测控制律，对非线性系统施加优化控，实验效果良好；马昌喜等利用粒子群算法求解城市环路交通协调控制系统，效果良好。<br>（3）用于多目标优化：莫愿斌等利用粒子群算法求解多目标过程系统优化；贺益君等就补料分批生化反应器的动态多目标优化应用粒子群算法求解；张文明等针对水文模型的参数多目标优化应用粒子群算法求解；彭志平等针对协商僵局的多目标问题利用粒子群算法消解，其僵局解决能力明显比现有的其他方法强。<br>从以上的分析可以看出，从应用角度看粒子群算法应用于求解越来越复杂的问题，同时对粒子群算法的改进也越来越精细，优化性能也大大加强，但对算法优化性能的改进还没有结束，如何更精细、更简洁地改进算法，提高其性能，用于求解更多更复杂的问题，仍是一个研究的热点。[3]   </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Fukuyama Y. Fundamentals of particle swarm techniques [A]. Lee K Y , El2Sharkawi M A. Modern Heuristic Optimization Techniques With Applications to Power Systems [M]. IEEE Power Engineering Society , 2002. 45～51<br>[2]陈子廓, 史宪睿. 基于觅食生境选择的改进粒子群算法[J]. 辽宁工业大学学报:自然科学版, 2022, 42(1):3.<br>[3]莫愿斌，刘贺同，陈德钊，粒子群优化算法的发展趋势 TP 183; TQ 015.9; 06-39:A，1001-4160(2009)04-430-434<br>[4]杨维, 李歧强. 粒子群优化算法综述[J]. 中国工程科学, 2004, 006(005):87-94.<br>[5]屈新怀, 单笛, 孟冠军. 基于靠近目标粒子群算法的AGV路径规划[J]. 合肥工业大学学报:自然科学版.<br>[6]Ali F A , Selvan K T . A study of PSO and its variants in respect of microstrip antenna feed point optimization[J]. IEEE, 2009:1817-1820.</p><hr><h1 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h1><p>题目：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/timu.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">粒子群算法实现</span></span><br><span class="line"><span class="string">作者：LP</span></span><br><span class="line"><span class="string">时间：2022年4月13日</span></span><br><span class="line"><span class="string">参考：https://blog.csdn.net/qq_38048756/article/details/108945267</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit_fun</span>(<span class="params">x</span>):  <span class="comment"># 适应函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="number">100.0</span> * (x[<span class="number">0</span>][<span class="number">1</span>:] - x[<span class="number">0</span>][:-<span class="number">1</span>] ** <span class="number">2.0</span>) ** <span class="number">2.0</span> + (<span class="number">1</span> - x[<span class="number">0</span>][:-<span class="number">1</span>]) ** <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Particle</span>:</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x_max, max_vel, dim</span>):</span><br><span class="line">        self.__pos = np.random.uniform(-x_max, x_max, (<span class="number">1</span>, dim))  <span class="comment"># 粒子的位置</span></span><br><span class="line">        self.__vel = np.random.uniform(-max_vel, max_vel, (<span class="number">1</span>, dim))  <span class="comment"># 粒子的速度</span></span><br><span class="line">        self.__bestPos = np.zeros((<span class="number">1</span>, dim))  <span class="comment"># 粒子最好的位置</span></span><br><span class="line">        self.__fitnessValue = fit_fun(self.__pos)  <span class="comment"># 适应度函数值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_pos</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__pos = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_pos</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__pos</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_best_pos</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__bestPos = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_best_pos</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__bestPos</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_vel</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__vel = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_vel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__vel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_fitness_value</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.__fitnessValue = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_fitness_value</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__fitnessValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PSO</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dim, size, iter_num, x_max, max_vel, tol, best_fitness_value=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;Inf&#x27;</span></span>), C1=<span class="number">2</span>, C2=<span class="number">2</span>, W=<span class="number">1</span></span>):</span><br><span class="line">        self.C1 = C1</span><br><span class="line">        self.C2 = C2</span><br><span class="line">        self.W = W</span><br><span class="line">        self.dim = dim  <span class="comment"># 粒子的维度</span></span><br><span class="line">        self.size = size  <span class="comment"># 粒子个数</span></span><br><span class="line">        self.iter_num = iter_num  <span class="comment"># 迭代次数</span></span><br><span class="line">        self.x_max = x_max</span><br><span class="line">        self.max_vel = max_vel  <span class="comment"># 粒子最大速度</span></span><br><span class="line">        self.tol = tol  <span class="comment"># 截至条件</span></span><br><span class="line">        self.best_fitness_value = best_fitness_value</span><br><span class="line">        self.best_position = np.zeros((<span class="number">1</span>, dim))  <span class="comment"># 种群最优位置</span></span><br><span class="line">        self.fitness_val_list = []  <span class="comment"># 每次迭代最优适应值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对种群进行初始化</span></span><br><span class="line">        self.Particle_list = [Particle(self.x_max, self.max_vel, self.dim) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bestFitnessValue</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.best_fitness_value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bestFitnessValue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.best_fitness_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bestPosition</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.best_position = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bestPosition</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.best_position</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新速度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_vel</span>(<span class="params">self, part</span>):</span><br><span class="line">        vel_value = self.W * part.get_vel() + self.C1 * np.random.rand() * (part.get_best_pos() - part.get_pos()) + self.C2 * np.random.rand() * (self.get_bestPosition() - part.get_pos())</span><br><span class="line">        vel_value[vel_value &gt; self.max_vel] = self.max_vel</span><br><span class="line">        vel_value[vel_value &lt; -self.max_vel] = -self.max_vel</span><br><span class="line">        part.set_vel(vel_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新位置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_pos</span>(<span class="params">self, part</span>):</span><br><span class="line">        pos_value = part.get_pos() + part.get_vel()</span><br><span class="line">        part.set_pos(pos_value)</span><br><span class="line">        value = fit_fun(part.get_pos())</span><br><span class="line">        <span class="keyword">if</span> value &lt; part.get_fitness_value():</span><br><span class="line">            part.set_fitness_value(value)</span><br><span class="line">            part.set_best_pos(pos_value)</span><br><span class="line">        <span class="keyword">if</span> value &lt; self.get_bestFitnessValue():</span><br><span class="line">            self.set_bestFitnessValue(value)</span><br><span class="line">            self.set_bestPosition(pos_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_ndim</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.iter_num):</span><br><span class="line">            <span class="keyword">for</span> part <span class="keyword">in</span> self.Particle_list:</span><br><span class="line">                self.update_vel(part)  <span class="comment"># 更新速度</span></span><br><span class="line">                self.update_pos(part)  <span class="comment"># 更新位置</span></span><br><span class="line">            self.fitness_val_list.append(self.get_bestFitnessValue())  <span class="comment"># 每次迭代完把当前的最优适应度存到列表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第&#123;&#125;次最佳适应值为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, self.get_bestFitnessValue()))</span><br><span class="line">            <span class="keyword">if</span> self.get_bestFitnessValue() &lt; self.tol:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.fitness_val_list, self.get_bestPosition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pso = PSO(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">1e-4</span>, C1=<span class="number">2</span>, C2=<span class="number">2</span>, W=<span class="number">1</span>)</span><br><span class="line">    fit_var_list, best_pos = pso.update_ndim()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最优位置:&quot;</span> + <span class="built_in">str</span>(best_pos))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span> + <span class="built_in">str</span>(fit_var_list[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>实验结果：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/res.png"></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法 python实现</title>
      <link href="/2022/08/08/Simulated-Annealing/"/>
      <url>/2022/08/08/Simulated-Annealing/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>模拟退火算法</strong>(Simulated Annealing，SA)最早的思想是由N. Metropolis 等人于1953年提出。1983 年,S. Kirkpatrick 等成功地将退火思想引入到组合优化领域。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法，其出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。 从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在求解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。<br><strong>优点：</strong>  </p><ul><li>模拟退火算法是一种通用的优化算法，理论上算法具有概率的全局优化性能。</li><li>赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优的串行结构的优化算法。</li></ul><p><strong>应用：</strong>  </p><ul><li>VLSI(超大规模集成电路)最优设计、图像处理、组合优化问题、生产调度、控制工程、机器学习、神经网络、信号处理等领域。</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>模拟退火算法包含两个部分即Metropolis算法和退火过程，分别对应内循环和外循环。外循环就是退火过程，将固体达到较高的温度（初始温度 T（0）），然后按照降温系数alpha使温度按照一定的比例下降，当达到终止温度Tf时，冷却结束，即退火过程结束。  </p><p>Metropolis算法是内循环，即在每次温度下，迭代L次，寻找在该温度下能量的最小值（即最优解）。  </p><p>下图中所示即为在一次温度下，跌代L次，固体能量发生的变化。在该温度下，整个迭代过程中温度不发生变化，能量发生变化，当前一个状态x(n)的能量大于后一个状态x(n+1)的能量时，状态x(n)的解没有状态x(n+1)的解好，所以接受状态x(n+1)。但是如果下一状态的能量比前一个状态的能量高时，该不该接受下一状态呢？在这里设置一个接受概率P,即如果下一状态的能量比前一个状态的能量高，则接受下一状态的概率为P,下面具体讲一下如何接受下一个状态。<br><img src="https://img-blog.csdnimg.cn/2020110414441182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"><br>Metropolis算法就是如何在局部最优解的情况下让其跳出来（如图中B、C、E为局部最优），是退火的基础。1953年Metropolis提出重要性采样方法，即以概率来接受新状态，而不是使用完全确定的规则，称为Metropolis准则，计算量较低。</p><p>假设开始状态在A，多次迭代之后更新到B的局部最优解，这时发现更新到B时，能力比A要低，则说明接近最优解了，因此百分百转移，状态到达B后，发现下一步能量上升了，如果是梯度下降则是不允许继续向前的，而这里会以一定的概率跳出这个坑，这各概率和当前的状态、能量等都有关系。所以说这个概率的设计是很重要的，下面从数学方面进行解释。</p><p>假设前一个状态为x(n),系统根据某一指标（梯度下降，上节的能量），状态变为x(n+1),相应的，系统的能量由E(n)变为E(n+1),定义系统由x(n)变为x(n+1)的接受概率P为：<br><img src="https://img-blog.csdnimg.cn/20201103203924739.png#pic_center"></p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="模拟退火的基本思想"><a href="#模拟退火的基本思想" class="headerlink" title="模拟退火的基本思想"></a>模拟退火的基本思想</h2><ol><li><p>初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L</p></li><li><p>对k&#x3D;1, …, L做第(3)至第6步：</p></li><li><p>产生新解S′</p></li><li><p>计算增量ΔT&#x3D;C(S′)-C(S)，其中C(S)为目标函数,C(S)相当于能量</p></li><li><p>若ΔT&lt;0则接受S′作为新的当前解，否则以概率exp(-ΔT&#x2F;T)接受S′作为新的当前解.</p></li><li><p>如果满足终止条件则输出当前解作为最优解，结束程序。</p></li><li><p>T逐渐减少，且T-&gt;0，然后转第2步。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/2020110414475911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="模拟退火算法新解的产生和接受可分为如下四个步骤"><a href="#模拟退火算法新解的产生和接受可分为如下四个步骤" class="headerlink" title="模拟退火算法新解的产生和接受可分为如下四个步骤"></a>模拟退火算法新解的产生和接受可分为如下四个步骤</h2><ol><li><p>第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。  </p></li><li><p>第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。  </p></li><li><p>第三步是判断新解是否被接受,判断的依据是一个接受准则，最常用的接受准则是Metropolis准则: 若ΔT&lt;0则接受S′作为新的当前解S，否则以概率P接受S′作为新的当前解S。  </p></li><li><p>第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。</p></li></ol><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src="https://img-blog.csdnimg.cn/20201104152404601.png#pic_center"></p><blockquote><p>在该实例中f(x)为目标函数，即为能量。然后设置控制参数t(温度）。求目标函数f(x)的最小值和最优状态（最小值情况下x1和x2的值）,即x1,x2在-5和5之间分别取何值时目标函数f(x)的值最小。在每次迭代中，x1,x2在-5到5之间取任意值。<br>首先设置初始温度为T0 &#x3D;100,降温系数为alpha &#x3D;0.99,终止温度为Tf &#x3D;0.01,内循环迭代次数iter &#x3D;100。<br>下面是完整代码：</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):                  <span class="comment">#函数优化问题</span></span><br><span class="line">    res= <span class="number">4</span>*x**<span class="number">2</span>-<span class="number">2.1</span>*x**<span class="number">4</span>+x**<span class="number">6</span>/<span class="number">3</span>+x*y-<span class="number">4</span>*y**<span class="number">2</span>+<span class="number">4</span>*y**<span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment">#x为公式里的x1,y为公式里面的x2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func, <span class="built_in">iter</span>=<span class="number">100</span>, T0=<span class="number">100</span>, Tf=<span class="number">0.01</span>, alpha=<span class="number">0.99</span></span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.<span class="built_in">iter</span> = <span class="built_in">iter</span>         <span class="comment">#内循环迭代次数,即为L =100</span></span><br><span class="line">        self.alpha = alpha       <span class="comment">#降温系数，alpha=0.99</span></span><br><span class="line">        self.T0 = T0             <span class="comment">#初始温度T0为100</span></span><br><span class="line">        self.Tf = Tf             <span class="comment">#温度终值Tf为0.01</span></span><br><span class="line">        self.T = T0              <span class="comment">#当前温度</span></span><br><span class="line">        self.x = [random() * <span class="number">11</span> -<span class="number">5</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">iter</span>)] <span class="comment">#随机生成100个x的值</span></span><br><span class="line">        self.y = [random() * <span class="number">11</span> -<span class="number">5</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">iter</span>)] <span class="comment">#随机生成100个y的值</span></span><br><span class="line">        self.most_best =[]</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        random()这个函数取0到1之间的小数</span></span><br><span class="line"><span class="string">        如果你要取0-10之间的整数（包括0和10）就写成 (int)random()*11就可以了，11乘以零点多的数最大是10点多，最小是0点多</span></span><br><span class="line"><span class="string">        该实例中x1和x2的绝对值不超过5（包含整数5和-5），（random() * 11 -5）的结果是-6到6之间的任意值（不包括-6和6）</span></span><br><span class="line"><span class="string">        （random() * 10 -5）的结果是-5到5之间的任意值（不包括-5和5），所有先乘以11，取-6到6之间的值，产生新解过程中，用一个if条件语句把-5到5之间（包括整数5和-5）的筛选出来。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.history = &#123;<span class="string">&#x27;f&#x27;</span>: [], <span class="string">&#x27;T&#x27;</span>: []&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_new</span>(<span class="params">self, x, y</span>):   <span class="comment">#扰动产生新解的过程</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            x_new = x + self.T * (random() - random())</span><br><span class="line">            y_new = y + self.T * (random() - random())</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">5</span> &lt;= x_new &lt;= <span class="number">5</span>) &amp; (-<span class="number">5</span> &lt;= y_new &lt;= <span class="number">5</span>):  </span><br><span class="line">                <span class="keyword">break</span>                                  <span class="comment">#重复得到新解，直到产生的新解满足约束条件</span></span><br><span class="line">        <span class="keyword">return</span> x_new, y_new </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Metrospolis</span>(<span class="params">self, f, f_new</span>):   <span class="comment">#Metropolis准则</span></span><br><span class="line">        <span class="keyword">if</span> f_new &lt;= f:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = math.exp((f - f_new) / self.T)</span><br><span class="line">            <span class="keyword">if</span> random() &lt; p:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">best</span>(<span class="params">self</span>):    <span class="comment">#获取最优目标函数值</span></span><br><span class="line">        f_list = []    <span class="comment">#f_list数组保存每次迭代之后的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">iter</span>):</span><br><span class="line">            f = self.func(self.x[i], self.y[i])</span><br><span class="line">            f_list.append(f)</span><br><span class="line">        f_best = <span class="built_in">min</span>(f_list)</span><br><span class="line">        </span><br><span class="line">        idx = f_list.index(f_best)</span><br><span class="line">        <span class="keyword">return</span> f_best, idx    <span class="comment">#f_best,idx分别为在该温度下，迭代L次之后目标函数的最优解和最优解的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#外循环迭代，当前温度小于终止温度的阈值</span></span><br><span class="line">        <span class="keyword">while</span> self.T &gt; self.Tf:       </span><br><span class="line">           </span><br><span class="line">            <span class="comment">#内循环迭代100次</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">iter</span>): </span><br><span class="line">                f = self.func(self.x[i], self.y[i])                    <span class="comment">#f为迭代一次后的值</span></span><br><span class="line">                x_new, y_new = self.generate_new(self.x[i], self.y[i]) <span class="comment">#产生新解</span></span><br><span class="line">                f_new = self.func(x_new, y_new)                        <span class="comment">#产生新值</span></span><br><span class="line">                <span class="keyword">if</span> self.Metrospolis(f, f_new):                         <span class="comment">#判断是否接受新值</span></span><br><span class="line">                    self.x[i] = x_new             <span class="comment">#如果接受新值，则把新值的x,y存入x数组和y数组</span></span><br><span class="line">                    self.y[i] = y_new</span><br><span class="line">            <span class="comment"># 迭代L次记录在该温度下最优解</span></span><br><span class="line">            ft, _ = self.best()</span><br><span class="line">            self.history[<span class="string">&#x27;f&#x27;</span>].append(ft)</span><br><span class="line">            self.history[<span class="string">&#x27;T&#x27;</span>].append(self.T)</span><br><span class="line">            <span class="comment">#温度按照一定的比例下降（冷却）</span></span><br><span class="line">            self.T = self.T * self.alpha        </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 得到最优解</span></span><br><span class="line">        f_best, idx = self.best()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;F=<span class="subst">&#123;f_best&#125;</span>, x=<span class="subst">&#123;self.x[idx]&#125;</span>, y=<span class="subst">&#123;self.y[idx]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">sa = SA(func)</span><br><span class="line">sa.run()</span><br><span class="line"></span><br><span class="line">plt.plot(sa.history[<span class="string">&#x27;T&#x27;</span>], sa.history[<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">plt.gca().invert_xaxis()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2020111014271776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_48241292/article/details/109468947">https://blog.csdn.net/weixin_48241292/article/details/109468947</a><br><a href="https://arxiv.org/abs/quant-ph/0205020">Study of Optimization Problems by Quantum Annealing</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo butterfly主题添加备案信息</title>
      <link href="/2022/03/30/hexo-add-ICP/"/>
      <url>/2022/03/30/hexo-add-ICP/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天腾讯云的客服给我打电话让我在网站页脚添加备案信息<br>网上找了一个方法使用后hexo报错<br>链接如下：<br><a href="https://blog.csdn.net/qq_51604330/article/details/114530264">https://blog.csdn.net/qq_51604330/article/details/114530264</a><br>不过总归是让我找到了改的位置，下面介绍修改方法</p><h1 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h1><ol><li><p>按照路径找到footer.pug文件<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330223752.png"></p></li><li><p>打开文件并在图示位置添加一下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.framework-info</span><br><span class="line">  img(src = &#x27;https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png&#x27;)</span><br><span class="line">  span= &#x27; &#x27;</span><br><span class="line">  a(href=&#x27;https://beian.miit.gov.cn/&#x27;)= &#x27;黔ICP备2022002429号-1&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330223954.png"></p></li></ol><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330224116.png"></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法python实现</title>
      <link href="/2022/03/27/Genetic-Algorithm/"/>
      <url>/2022/03/27/Genetic-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上课学的基础遗传算法，我用python实现了一遍。<br>选择算法使用轮盘赌博<br>基因交叉每次一位<br>基因变异每次一位  </p><p>算法效果不是很好，有大佬熟悉的话感谢留言指导一下。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求解函数的最大值y&#x3D;xsin(10x)+xsin(2x),自变量取值：0–5<br>函数图像：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/1.png">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">作者：LP</span></span><br><span class="line"><span class="string">时间：2022年3月24日</span></span><br><span class="line"><span class="string">介绍：遗传算法</span></span><br><span class="line"><span class="string">参考：https://blog.csdn.net/weixin_42053726/article/details/82722758</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">题目：y=xsin(10x)+xsin(2x),自变量取值：0-5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gene_len</span>(<span class="params"><span class="built_in">len</span>, accu</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因长度计算</span></span><br><span class="line"><span class="string">    参数： len 区间长度(整型)</span></span><br><span class="line"><span class="string">         accu 精确度（精确到小数点后多少位）</span></span><br><span class="line"><span class="string">    返回值： 二进制长度</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    temp = <span class="built_in">len</span> * (<span class="number">10</span> ** accu)</span><br><span class="line">    <span class="comment"># print(temp)</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> temp &gt; <span class="number">2</span> :</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        temp = temp / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gene_decode</span>(<span class="params">arr,a,b,accu</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将列表转换为十进制数并映射到区间上</span></span><br><span class="line"><span class="string">    参数： arr 基因列表</span></span><br><span class="line"><span class="string">           a 区间起始点</span></span><br><span class="line"><span class="string">           b 区间终点</span></span><br><span class="line"><span class="string">           accu 精确到小数点后多少位</span></span><br><span class="line"><span class="string">    返回值： 十进制数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#二进制转十进制</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">        temp = j * (<span class="number">2</span> ** i) + temp</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="comment">#映射到区间上</span></span><br><span class="line">    res = a + (b-a)/(<span class="number">2</span>**<span class="built_in">len</span>(arr)-<span class="number">1</span>)*temp</span><br><span class="line">    res = <span class="built_in">round</span>(res, accu)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gene_init</span>(<span class="params">pop, <span class="built_in">len</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化基因序列</span></span><br><span class="line"><span class="string">    参数：  pop 种群个数 </span></span><br><span class="line"><span class="string">            len 个体基因长度</span></span><br><span class="line"><span class="string">    返回值： 二维数组 长度为种群个数 每个元素为个体基因序列</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randint(<span class="number">2</span>, size=(pop, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">x</span>): <span class="keyword">return</span> np.sin(<span class="number">10</span>*x)*x + np.cos(<span class="number">2</span>*x)*x + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fitness</span>(<span class="params">pop, func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取每个个体的适应度</span></span><br><span class="line"><span class="string">    参数：  pop 种群二位数组</span></span><br><span class="line"><span class="string">            func 目标函数</span></span><br><span class="line"><span class="string">    返回值： 每个个体的适应度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fit = []</span><br><span class="line">    prob = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pop:</span><br><span class="line">        fit.append(func(gene_decode(i,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>)))    <span class="comment">#每个基因的适应度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fit)):</span><br><span class="line">        prob.append(fit[i]/<span class="built_in">sum</span>(fit))        <span class="comment">#每个基因被选中的概率 </span></span><br><span class="line">    <span class="comment"># print(fit)</span></span><br><span class="line">    <span class="comment"># print(prob)</span></span><br><span class="line">    <span class="comment"># print(sum(prob))</span></span><br><span class="line">    <span class="keyword">return</span> fit,prob</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selec</span>(<span class="params">pop, prob</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    轮盘赌方法 根据概率选择个体 更新种群二维数组</span></span><br><span class="line"><span class="string">    参数：  pop 种群二位数组</span></span><br><span class="line"><span class="string">            prob 概率数组</span></span><br><span class="line"><span class="string">    返回值： 新的种群二维数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rand_prob = np.random.random(<span class="built_in">len</span>(prob))</span><br><span class="line">    new_pop = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rand_prob:</span><br><span class="line">        <span class="comment"># print(&quot;prob:&quot;+str(i))</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prob)):</span><br><span class="line">            <span class="built_in">sum</span> += prob[j]</span><br><span class="line">            <span class="comment"># print(&quot;dangqianprob:&quot;+str(sum))</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                new_pop.append(<span class="built_in">list</span>(pop[j]))</span><br><span class="line">                <span class="comment"># print(new_pop)</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> new_pop</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gene_cross</span>(<span class="params">pop, cross_rate</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因交叉（单点交叉） 根据概率选择交叉点</span></span><br><span class="line"><span class="string">    参数：pop 种群二维数组</span></span><br><span class="line"><span class="string">            cross_rate 基因交叉概率</span></span><br><span class="line"><span class="string">    返回值：新的种群二位数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> cross_rate &lt; np.random.random():</span><br><span class="line">        local = np.random.randint(<span class="built_in">len</span>(pop[<span class="number">0</span>]))    <span class="comment">#选择交叉点位</span></span><br><span class="line">        gene_one = np.random.randint(<span class="built_in">len</span>(pop))    <span class="comment">#选择交叉的第一个基因</span></span><br><span class="line">        gene_two = np.random.randint(<span class="built_in">len</span>(pop))    <span class="comment">#选择交叉的第二个基因</span></span><br><span class="line">        <span class="keyword">while</span> gene_one == gene_two:</span><br><span class="line">            gene_two = np.random.randint(<span class="built_in">len</span>(pop))</span><br><span class="line">        temp = pop[gene_one][local]</span><br><span class="line">        pop[gene_one][local] = pop[gene_two][local]</span><br><span class="line">        pop[gene_two][local] = temp</span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gene_change</span>(<span class="params">pop, change_rate</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因突变（单点突变） 根据概率选择突变点</span></span><br><span class="line"><span class="string">    参数： pop 种群二维数组</span></span><br><span class="line"><span class="string">            change_rate 基因突变概率</span></span><br><span class="line"><span class="string">    返回值：新的种群二位数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> change_rate &lt; np.random.random():</span><br><span class="line">        local = np.random.randint(<span class="built_in">len</span>(pop[<span class="number">0</span>]))  <span class="comment">#选择个体的基因位置</span></span><br><span class="line">        gene_choice = np.random.randint(<span class="built_in">len</span>(pop))   <span class="comment">#选择个体</span></span><br><span class="line">        pop[gene_choice][local] ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pop = gene_init(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>): </span><br><span class="line">        [fit, prob] = fitness(pop, F)</span><br><span class="line">        pop = selec(pop,prob)</span><br><span class="line">        pop = gene_cross(pop, <span class="number">0.8</span>)</span><br><span class="line">        pop = gene_change(pop, <span class="number">0.8</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pop:</span><br><span class="line">        <span class="built_in">print</span>(gene_decode(i,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">    <span class="comment"># print(gene_decode([1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1],-1,2, 6))</span></span><br><span class="line">    <span class="comment"># print(gene_len(3,1))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云+Picgo搭建图床</title>
      <link href="/2022/03/26/pic-bed/"/>
      <url>/2022/03/26/pic-bed/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前用的遇见图床，很多图片链接资源被清除。辛辛苦苦写的博客啊，图床一挂什么图片都没了。图床还是自己建一个靠谱。<br>几天前折腾了一下七牛云，10G免费存储空间，看似不错。结果我的站点是https，免费的七牛云只提供http，导致上传了图片在浏览器里加载不出来。<br>果断选择付费的，现在每个平台的oss价格都不贵，我的服务器用的腾讯云，所以图床用腾讯云的COS，这样内网访问可以节省流量。<br>接下来介绍搭建方法。</p><span id="more"></span><h1 id="腾讯云cos"><a href="#腾讯云cos" class="headerlink" title="腾讯云cos"></a>腾讯云cos</h1><p>打开腾讯云注册帐号、实名认证、获取cos的免费存储…</p><h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>创建存储桶（存储同bucket可以理解为存东西的空间）：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327204518.png"><br>按照官方的说明配置就行了  </p><p>访问权限这里因为是博客图床，我选择公有读私有写，最后一行这里腾讯云会提供一个免费的https链接我们可以用这个链接访问到图传的图片（或者你用域名解析到这个链接也可以）<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327204851.png"></p><p>后面的看着选，不懂得可以读一下文档，写的很清楚。<br>这样一个图床就建好了。  </p><h2 id="picgo需要用的参数"><a href="#picgo需要用的参数" class="headerlink" title="picgo需要用的参数"></a>picgo需要用的参数</h2><p>picgo需要用的参数位置先展示给大家看一下：<br><code>空间名</code>和<code>区域</code>：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327205911.png"><br>点击进入下图中的<code>访问密钥</code>，然后新建密钥即可获得<code>APPID</code>、<code>SecretId</code>和<code>SecretKey</code><br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327210023.png"></p><h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载链接</a></p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>进入图床设置-&gt;腾讯云cos，安装之前讲的位置填入相应的参数，选择设为默认图床然后确定：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327211030.png"></p><p>这样我们就能进入上传区快乐的传图片啦！<br>上传区支持url上床和剪贴板上传，上传后图片链接会自动复制到剪贴板。</p><h2 id="PicGo官方文档"><a href="#PicGo官方文档" class="headerlink" title="PicGo官方文档"></a>PicGo官方文档</h2><p>有什么不懂的可以去<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">PicGo官方文档</a></p><h1 id="vscode-PicGo"><a href="#vscode-PicGo" class="headerlink" title="vscode + PicGo"></a>vscode + PicGo</h1><p>强烈建议大家使用vscode中的picgo插件，<code>ctrl</code>+<code>alt</code>+<code>u</code>直接剪贴板上传并在光标位置写入markdown链接，很舒服！！！<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327212400.png"><br>安装后按照上文中的参数配置就能用了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>PicGo：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a><br>vscode picgo插件：<a href="https://baijiahao.baidu.com/s?id=1657980156535147441&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1657980156535147441&amp;wfr=spider&amp;for=pc</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picBed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将hexo配置到个人服务器 nginx配置https</title>
      <link href="/2022/03/26/hexoToMyServer/"/>
      <url>/2022/03/26/hexoToMyServer/</url>
      
        <content type="html"><![CDATA[<p>hexo配置到github国内访问不用梯子上不去，一直想把博客放到自己的服务器上，这样baidu也可以收录。接下来介绍一下配置过程。  </p><span id="more"></span>  <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>云服务器 ubuntu20.04<br>本地主机装好hexo（不会的可以看下我之前关于hexo的文章）  </p><h1 id="将hexo配置到个人服务器"><a href="#将hexo配置到个人服务器" class="headerlink" title="将hexo配置到个人服务器"></a>将hexo配置到个人服务器</h1><h2 id="安装git和nginx"><a href="#安装git和nginx" class="headerlink" title="安装git和nginx"></a>安装git和nginx</h2><p>以下操作建立在 <code>root</code> 权限之下，如权限不足请申请 <code>root</code> 权限或采用 <code>sudo</code> 关键字。  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install git nginx -y</span><br></pre></td></tr></table></figure><p>安装完成后新建一个文件路径来存放我们的git仓库并初始化仓库：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo/</span><br><span class="line">cd /var/repo</span><br><span class="line">git init --bare &#123;自定义仓库名name&#125;.git</span><br></pre></td></tr></table></figure><h2 id="配置-Nginx-托管文件目录"><a href="#配置-Nginx-托管文件目录" class="headerlink" title="配置 Nginx 托管文件目录"></a>配置 Nginx 托管文件目录</h2><p>创建一个新的www目录（如果想使用默认的可以跳过这一小节）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/www/hexo</span><br></pre></td></tr></table></figure><p>修改 Nginx 的 default 文件使得 root 指向刚刚创建的 &#x2F;var&#x2F;www&#x2F;hexo目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到root字段并修改为：</span></span><br><span class="line">root /var/www/hexo</span><br></pre></td></tr></table></figure><p>重启nginx服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>配置完成。</p><blockquote><p>tips:可以自己随便写个网页放到这个目录，ip访问一下服务器看看配置成功没有。</p></blockquote><h2 id="Git勾子（hooks）"><a href="#Git勾子（hooks）" class="headerlink" title="Git勾子（hooks）"></a>Git勾子（hooks）</h2><p>我们的hexo文件传到服务器的git后，需要同步传到nginx的托管目录下。这样访问网站时才会有hexo的内容,这就需要使用git hooks。</p><p>执行下面的命令，在自动生成的<code>&#123;自定义仓库名name&#125;.git/hooks</code> 目录下创建一个新的钩子文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /var/repo/&#123;自定义仓库名name&#125;.git/hooks/post-receive</span><br></pre></td></tr></table></figure><blockquote><p>tips:注意这是要新建一个文件，而不是用<code>post-update.sample</code>这个文件。我踩了粗心大意的坑    </p></blockquote><p>打开文件后，加入下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/&#123;自定义仓库名name&#125;.git checkout -f</span><br></pre></td></tr></table></figure><p>将文件保存后，赋予该文件可执行权限:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /var/repo/&#123;自定义仓库名name&#125;.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h2 id="使用Git部署本地Hexo到远端"><a href="#使用Git部署本地Hexo到远端" class="headerlink" title="使用Git部署本地Hexo到远端"></a>使用Git部署本地Hexo到远端</h2><p>将服务器地址添加到受信任的站点，在本地任意目录从服务器上把hexo_static仓库克隆下来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone root@&#123;云服务器IP&#125;:/var/repo/ganahBlog.git</span><br></pre></td></tr></table></figure><blockquote><p>tips: 如果你在远端服务器创建了 Git 用户并设定为拥有者，请将 root 改成 git （git用户）。</p></blockquote><p>编辑本地hexo工作目录中的<code>_config.yml</code>,将<code>url</code>改成<code>https://&#123;云服务器IP或域名&#125;/</code></p><p>将 deploy 目标改为 {服务器用户名}@{服务IP}:&#x2F;var&#x2F;repo&#x2F;{自定义仓库名name}.git：<br><img src="https://pic4.zhimg.com/80/v2-82fe5b073a41cc15a722fa9d2ca54b33_720w.jpg"></p><p>在个人博客站点目录下，打开 <code>Git bash</code> ,使用 <code>hexo clean &amp;&amp; hexo g -d</code> 部署</p><blockquote><p>这里如果不想每次都输密码，可以将本地的<code>id_rsa.pub</code>文件写入服务器用户家目录的.ssh文件夹中<br>具体操作参考：<a href="https://blog.csdn.net/jewely/article/details/104743806/%EF%BC%88ssh%E5%AF%86%E9%92%A5%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86%EF%BC%89">https://blog.csdn.net/jewely/article/details/104743806/（ssh密钥的生成和配置部分）</a></p></blockquote><p>至此，可使用IP地址访问博客。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327160102.png"></p><h1 id="nginx配置https"><a href="#nginx配置https" class="headerlink" title="nginx配置https"></a>nginx配置https</h1><h2 id="获取证书文件"><a href="#获取证书文件" class="headerlink" title="获取证书文件"></a>获取证书文件</h2><p>自己去域名商那里申请一个nginx的证书文件（或者自己openssl签发），一般是如下几个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">callmelp.online.csr</span><br><span class="line">callmelp.online.key</span><br><span class="line">callmelp.online_bundle.crt</span><br><span class="line">callmelp.online_bundle.pem</span><br></pre></td></tr></table></figure><p>我们需要用的是.crt和.key文件</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>在域名商那边把域名解析到自己服务器的ip地址</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>添加https站点：修改 <code>/etc/nginx/sites-enabled/default</code>站点的配置文件(记得自己先备份)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 443;</span><br><span class="line">   server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">   ssl on;</span><br><span class="line">   root /var/www/www.domain.com; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span><br><span class="line">   index index.html index.htm;   </span><br><span class="line">   ssl_certificate  /usr/local/nginx/conf/1_www.domain.com_bundle.crt; #证书文件路径+名称</span><br><span class="line">   ssl_certificate_key /usr/local/nginx/conf/2_www.domain.com.key; #私钥文件路径+名称</span><br><span class="line">   ssl_session_timeout 5m;</span><br><span class="line">   ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">   ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">   ssl_prefer_server_ciphers on;</span><br><span class="line">   location / &#123;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">   rewrite ^(.*)$ https://$host$1 permanent; #把http的域名请求转成https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>将hexo个人博客部署到个人云服务器<a href="https://zhuanlan.zhihu.com/p/120743882">https://zhuanlan.zhihu.com/p/120743882</a><br>Ubuntu下nginx服务器开启https的方法<a href="https://cloud.tencent.com/developer/article/1456497">https://cloud.tencent.com/developer/article/1456497</a><br><a href="https://blog.csdn.net/jewely/article/details/104743806/">https://blog.csdn.net/jewely/article/details/104743806/</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程与多线程的区别</title>
      <link href="/2022/01/08/asynoioAndthreading/"/>
      <url>/2022/01/08/asynoioAndthreading/</url>
      
        <content type="html"><![CDATA[<h1 id="异步编程与多线程的区别"><a href="#异步编程与多线程的区别" class="headerlink" title="异步编程与多线程的区别"></a>异步编程与多线程的区别</h1><p><strong>共同点</strong>:  </p><blockquote><p>异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性          </p></blockquote><p><strong>不同点</strong>：</p><blockquote><ol><li>线程不是一个计算机硬件的功能，而是<strong>操作系统提供</strong>的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统<strong>投入CPU资源</strong>来运行和调度。   <blockquote><p>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的<strong>额外负担</strong>。并且线程间的共享变量可能造成<strong>死锁</strong>的出现   </p></blockquote></li><li>异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。<br>  当然异步操作也并非完美无暇。编写异步操作的<strong>复杂程度较高</strong>，程序主要使用回调方式进行处理，与普通人的思维方式有些出入，而且难以调试。<blockquote><p>这里有一个疑问。异步操作没有创建新的线程，我们一定会想，比如有一个文件操作，大量数据从硬盘上读取，若使用单线程的同步操作自然要等待会很长时间，但是若使用异步操作的话，我们让数据读取异步进行，二线程在数据读取期间去干其他的事情，我们会想，这怎么行呢，异步没有创建其他的线程，一个线程去干其他的事情去了，那数据的读取异步执行是去由谁完成的呢？实际上，本质是这样的:<br>  熟悉电脑硬件的朋友肯定对<strong>DMA</strong>这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。<strong>DMA就是直接内存访问的意思</strong>，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，<strong>硬件就开始自己和内存交换数据</strong>，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I&#x2F;O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。即CPU在数据的长时间读取过程中 ，只需要做两件事，第一发布指令，开始数据交换；第二，交换结束，得到指令，CPU再进行后续操作。而中间读取数据漫长的等待过程，<strong>CPU本身就不需要参与</strong>，顺序执行就是我不参与但是我要干等着，效率低下；异步执行就是，我不需要参与那我就去干其他事情去了，你做完了再通知我就可以了（回调）。<br>  但是你想一下，如果有一些异步操作必须要CPU的参与才能完成呢，即我开始的那个线程是走不开的，这该怎么办呢，在python中这是系统自己去安排的，无需人工干预，这就比自己创建很多的线程更加高效。</p></blockquote></li></ol></blockquote><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>“多线程”，第一、最大的问题在于线程本身的调度和运行<strong>需要很多时间</strong>，因此<strong>不建议自己创建太大量的线程</strong>；第二、<strong>共享资源的调度比较难</strong>，涉及到死锁，上锁等相关的概念。  </li><li>“异步” ，异步最大的问题在于“回调”，这增加了软件设计上的难度。</li></ol><p>在实际设计时，我们可以将两者结合起来：</p><ol><li>当需要执行<strong>I&#x2F;O操作</strong>时，使用<strong>异步操作</strong>比使用线程+同步I&#x2F;O操作更合适。I&#x2F;O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。异步特别适用于大多数IO密集型的应用程序。</li><li>而线程的适用范围则是那种需要<strong>长时间CPU运算的场合</strong>，例如耗时较长的图形处理和算法执行。但是往 往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I&#x2F;O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/yanan-boke/p/9395638.html">https://www.cnblogs.com/yanan-boke/p/9395638.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> threading </tag>
            
            <tag> asynoio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache2配置ssl证书使用https，反向代理</title>
      <link href="/2022/01/05/apache-ssl/"/>
      <url>/2022/01/05/apache-ssl/</url>
      
        <content type="html"><![CDATA[<p>证书申请过程这里不介绍，apache证书文件包含以下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1_root_bundle.crt # 证书文件</span><br><span class="line">2_xxx.xxx.xxx.crt # 证书文件</span><br><span class="line">3_xxx.xxx.xxx.key # 私钥文件</span><br></pre></td></tr></table></figure><h1 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h1><p>在这里，我假设你已经会配置基本的<code>/etc/apache2/sites-available/000-default.conf</code>这个文件来达到已经可以通过 http 的方式来访问你的站点。    </p><p>编辑<code>/etc/apache2/sites-available/default-ssl.conf</code>添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSLEngine on</span><br><span class="line">ServerName www.domain.com</span><br><span class="line"></span><br><span class="line">SSLCertificateChainFile /etc/apache2/ssl/2_xxx.xxx.xxx.crt</span><br><span class="line">SSLCertificateKeyFile /etc/apache2/ssl/3_xxx.xxx.xxx.key</span><br><span class="line">SSLCertificateFile /etc/apache2/ssl/1_root_bundle.crt</span><br></pre></td></tr></table></figure><h1 id="http自动跳转至https"><a href="#http自动跳转至https" class="headerlink" title="http自动跳转至https"></a>http自动跳转至https</h1><p>在<code>/etc/apache2/sites-available/000-default.conf</code>中添加一下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond   %&#123;HTTPS&#125; !=on</span><br><span class="line">RewriteRule   ^(.*)  https://%&#123;SERVER_NAME&#125;$1 [L,R]</span><br></pre></td></tr></table></figure><h1 id="使用https"><a href="#使用https" class="headerlink" title="使用https"></a>使用https</h1><p>终端中使能apache2的ssl模块：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a2enmod ssl</span><br></pre></td></tr></table></figure><p>重启apache2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><p>以上，网站即可通过https访问</p><hr><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>若需要使用<code>域名/目录</code>这种方式访问即设置反向代理</p><p><strong>例如在我的网站中，使用<a href="http://www.domain.com/wss%E6%9D%A5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD65318%E7%AB%AF%E5%8F%A3%E4%B8%AD%E7%9A%84ws%E6%9C%8D%E5%8A%A1">www.domain.com/wss来代理服务器中65318端口中的ws服务</a></strong>：<br>在<code>000-default.conf</code>中添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSLProxyEngine on</span><br><span class="line">ProxyRequests Off</span><br><span class="line">ProxyPass /wss ws://127.0.0.1:65318</span><br><span class="line">ProxyPassReverse /wss ws://127.0.0.1:65318</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache2 </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coturn服务器搭建及踩坑</title>
      <link href="/2022/01/05/coturn-server/"/>
      <url>/2022/01/05/coturn-server/</url>
      
        <content type="html"><![CDATA[<h1 id="安装coturn"><a href="#安装coturn" class="headerlink" title="安装coturn"></a>安装coturn</h1><p>安装之前，先确保使用以下命令将apt-get更新到最新：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装coturn：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install coturn</span><br></pre></td></tr></table></figure><p>请确保使用以下命令在安装软件包后停止该服务, 因为安装完成后它将自动启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop coturn</span><br></pre></td></tr></table></figure><h1 id="生成证书文件"><a href="#生成证书文件" class="headerlink" title="生成证书文件"></a>生成证书文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes </span><br></pre></td></tr></table></figure><h1 id="备份并创建配置文件"><a href="#备份并创建配置文件" class="headerlink" title="备份并创建配置文件"></a>备份并创建配置文件</h1><p>安装好coturn后会在<code>/etc</code>目录下创建<code>turnserver.conf</code><br>首先备份：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy the original turnserver configuration file to a backup <span class="keyword">in</span> the same directory</span></span><br><span class="line">cp /etc/turnserver.conf /etc/turnserver.conf.original</span><br></pre></td></tr></table></figure><p>用编辑器编辑<code>turnserver.conf</code>:  </p><blockquote><p>tips:<strong>内网地址</strong>是使用<code>ifconfig</code>后显示的地址，<strong>外网地址</strong>云服务器公网地址</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listening-device=eth0</span><br><span class="line">listening-port=3478</span><br><span class="line">tls-listening-port=5349   </span><br><span class="line">listening-ip=&lt;内网地址&gt;   </span><br><span class="line">external-ip=&lt;外网地址&gt;</span><br><span class="line">server-name=&lt;域名&gt;</span><br><span class="line">realm=&lt;域名&gt;</span><br><span class="line">lt-cred-mech                                                                                                   </span><br><span class="line">userdb=/var/lib/turn/turndb                                                                               </span><br><span class="line">cert=/etc/turn_server_cert.pem                                                                           </span><br><span class="line">pkey=/etc/turn_server_pkey.pem                                                                         </span><br><span class="line">no-stdout-log                                                                                                   </span><br><span class="line">log-file=/var/tmp/turnserver.log                                                                         </span><br><span class="line">pidfile=&quot;/var/run/turnserver.pid&quot; </span><br><span class="line">user=&lt;用户名&gt;:&lt;密码&gt;</span><br><span class="line">cli-password=qwerty</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/default/coturn</code>文件(去掉下面这句前面的#)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TURNSERVER_ENABLED=1</span><br></pre></td></tr></table></figure><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><p>云服务器端口打开：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1-65535 UDP  </span><br><span class="line">3478 TCP</span><br></pre></td></tr></table></figure><p>重启coturn：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service coturn restart</span><br></pre></td></tr></table></figure><p>这将启动服务器中的coturn服务。你可以使用以下命令检查服务的状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status coturn</span><br></pre></td></tr></table></figure><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327195746.png"></p><blockquote><p><strong>这里我踩的坑</strong>：记得关掉软件防火墙（ufw）!!!!!!!!!!<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327200006.png"></p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试地址:<a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/</a><br>看到 relay 类型的就说明成功了</p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coturn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电容器件选型</title>
      <link href="/2021/12/07/cChoice/"/>
      <url>/2021/12/07/cChoice/</url>
      
        <content type="html"><![CDATA[<h1 id="电容参数描述"><a href="#电容参数描述" class="headerlink" title="电容参数描述"></a>电容参数描述</h1><table><thead><tr><th align="center">电容</th><th align="center">陶瓷</th><th align="center">容值</th><th align="center">电压</th><th align="center">类型</th><th align="center">封装</th></tr></thead><tbody><tr><td align="center">CAP</td><td align="center">CER</td><td align="center">0.1UF</td><td align="center">16V</td><td align="center">Y5V</td><td align="center">0402</td></tr><tr><td align="center">CAP</td><td align="center">TANT</td><td align="center">1UF</td><td align="center">10%</td><td align="center">10V</td><td align="center">1206</td></tr><tr><td align="center">CAP</td><td align="center">CER</td><td align="center">0.1UF</td><td align="center">16V</td><td align="center">Y5V</td><td align="center">0402</td></tr></tbody></table><h1 id="电容参数特性"><a href="#电容参数特性" class="headerlink" title="电容参数特性"></a>电容参数特性</h1><p>（1）容量和误差：实际电容量和标称电容量允许的最大偏差范围。在选型上注意精度等级，用字母表示：D——±0.5%，F——±1%，G——±2%，J——±5 % ，K——±10%，M——±20%。<br>（2）额定工作电压：电容器在电路中能够长期稳定、可靠工作，所承受的最大直流电压。<br>（3）绝缘电阻：表示漏电大小，一般绝缘电阻越大越好，漏电也小电解电容的绝缘电阻一般较小。<br>（4）正切角损耗：在电场的作用下，电容器在单位时间内发热而消耗的能量。<br>（5）温度系数：在一定温度范围内，温度每变化1℃，电容量的相对变化值。温度系数越小越好。<br>（6）频率特性:电容器的电参数随电场频率而变化的性质。在高频条件下工作的电容器，由于介电常数在高频时比低频时小，电容量也相应减小。损耗也随频率的升高而增加。<br>（7）等效串联电阻（ESR）：损耗较大产品的ESR较大；随着容量的增大，产品的ESR将变小；钽电容的ESR特别小。  </p><h1 id="电容分类"><a href="#电容分类" class="headerlink" title="电容分类"></a>电容分类</h1><ol><li>陶瓷介质类</li><li>电解类： 钽、铝电解液</li><li>其他类（有机薄膜、云母、云母纸、空气）</li></ol><h1 id="电容型号命名"><a href="#电容型号命名" class="headerlink" title="电容型号命名"></a>电容型号命名</h1><p>依据(GB2470 -81 ) ，国产电容的型号命名一般由四部分组成，依次分别代表名称、材料、分类和序号。</p><ul><li>第一部分：名称，用字母表示，电容器用C。</li><li>第二部分：材料，用字母表示。</li><li>第三部分：分类，一般用数字表示，个别用字母表示。</li><li>第四部分：序号，用数字表示</li></ul><p><img src="https://www.hualigs.cn/image/60bdb77a0c4f3.jpg"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://www.hualigs.cn/image/60bdb8350b823.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HardWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电阻器件选型</title>
      <link href="/2021/12/07/rChoice/"/>
      <url>/2021/12/07/rChoice/</url>
      
        <content type="html"><![CDATA[<h1 id="电阻器件选型"><a href="#电阻器件选型" class="headerlink" title="电阻器件选型"></a>电阻器件选型</h1><h1 id="电阻介绍"><a href="#电阻介绍" class="headerlink" title="电阻介绍"></a>电阻介绍</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>薄膜电阻：碳膜电阻、合成碳膜电阻、尽速氧化膜电阻…</li><li>绕线电阻：通用绕线电阻、功率绕线电阻、高频线绕线电阻…</li><li>实心电阻: 无机合成实心碳质电阻和有机…</li><li>特种电阻：湿敏电阻、热敏电阻、压敏电阻、光敏电阻、磁敏电阻、力敏电阻、气敏电阻。</li></ul><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327200848.png"><br>常用为金属膜电阻（直插），金属玻璃铀电阻（贴片）</p><p>电阻描述示例：  </p><table><thead><tr><th align="center">电阻</th><th align="center">贴片</th><th align="center">阻值</th><th align="center">精度</th><th align="center">精度</th><th align="center">功率</th><th align="center">封装</th></tr></thead><tbody><tr><td align="center">RES</td><td align="center">SMD</td><td align="center">22K</td><td align="center">OHM</td><td align="center">1%</td><td align="center">1&#x2F;16W</td><td align="center">0402</td></tr><tr><td align="center">RES</td><td align="center">SMD</td><td align="center">22K</td><td align="center">OHM</td><td align="center">1%</td><td align="center">1&#x2F;16W</td><td align="center">0402</td></tr></tbody></table><h2 id="选型要点"><a href="#选型要点" class="headerlink" title="选型要点"></a>选型要点</h2><ul><li>电阻的<em><strong>阻值</strong></em>满足应用电路使用。</li><li>电阻的<em><strong>额定功率</strong></em>大于电阻在应用电路实际工作功率。一般按额定功率70%降额设计选用。</li><li>电阻在应用电路中<em><strong>实际工作电压</strong></em>小于最大工作电压。一般按最高工作电压的75%降额设计选用。</li><li>电阻的<em><strong>稳定性、工作频率、噪声</strong></em>等特性满足应用电路要求。</li></ul><h1 id="阻值的表示"><a href="#阻值的表示" class="headerlink" title="阻值的表示"></a>阻值的表示</h1><p>标称阻值的表示方法采用GB&#x2F;T2471中的E24、E48、E96、E192系列。</p><ul><li>E24:三位数字表述。前两位表示有效数字，第三位表示0的个数。</li><li>E96:四位字符表述。前三位表示有效数字，第四位表示0的个数。</li><li>E96系列三位字符表示法：用三位字符表示阻值，前两位数字表示E96系列序号，第三位代表10的n次幂</li></ul><h1 id="功率"><a href="#功率" class="headerlink" title="功率"></a>功率</h1><p>大部分情况下如下表所示：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201001.png"></p><h1 id="电阻尺寸"><a href="#电阻尺寸" class="headerlink" title="电阻尺寸"></a>电阻尺寸</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201057.png"></p><h1 id="上拉电阻"><a href="#上拉电阻" class="headerlink" title="上拉电阻"></a>上拉电阻</h1><h2 id="需要上拉的情况"><a href="#需要上拉的情况" class="headerlink" title="需要上拉的情况"></a>需要上拉的情况</h2><ol><li>TTL电路驱动coms电路时。</li><li>oc门电路加上拉电阻。</li><li>为加大输出引脚的驱动能力，有的单片机管脚上也常使用上拉电阻。</li><li>不适用管教。</li><li>线传输中电阻的匹配，一直反射波干扰…</li></ol><h2 id="上拉电阻选择"><a href="#上拉电阻选择" class="headerlink" title="上拉电阻选择"></a>上拉电阻选择</h2><ol><li>从节约功耗考虑应当足够大；电阻大，电流小。</li><li>从足够的驱动电流考虑应当足够小；电阻小，电流大。</li><li>对于高速电路，过大的上拉电阻可能边沿变平缓。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HardWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用流程</title>
      <link href="/2021/09/04/github-log/"/>
      <url>/2021/09/04/github-log/</url>
      
        <content type="html"><![CDATA[<p>记录一下github每次使用中需要进行的操作：</p><h1 id="Github流程"><a href="#Github流程" class="headerlink" title="Github流程"></a>Github流程</h1><h2 id="创建新仓库并上传"><a href="#创建新仓库并上传" class="headerlink" title="创建新仓库并上传"></a>创建新仓库并上传</h2><ol><li><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220814223830.png"></p></li><li><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220814223907.png"></p></li><li><p>如果本地没有创建仓库,先在本地运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:[username]/learngit.git</span><br></pre></td></tr></table></figure><p><code>username</code>的地方填你的用户名，远程库的名字是<code>origin</code>，这是Git默认的叫法。   </p></li><li><p>本地添加git文件，添加缓存区并提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>下一步，就可以把本地库的所有内容推送到远程库上：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<br>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li></ol><h2 id="查看缓存区状态"><a href="#查看缓存区状态" class="headerlink" title="查看缓存区状态"></a>查看缓存区状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="删除git分支"><a href="#删除git分支" class="headerlink" title="删除git分支"></a>删除git分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令：$ git push origin 【空格】【冒号】【需要删除的分支名字】</span><br><span class="line">例：  $ git push origin :main</span><br></pre></td></tr></table></figure><h2 id="删除远程仓库已经提交的文件"><a href="#删除远程仓库已经提交的文件" class="headerlink" title="删除远程仓库已经提交的文件"></a>删除远程仓库已经提交的文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><blockquote><p>加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态     </p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/xyr05288/article/details/80829679">https://blog.csdn.net/xyr05288/article/details/80829679</a><br><a href="https://blog.csdn.net/taowuhua0505/article/details/80499540">https://blog.csdn.net/taowuhua0505/article/details/80499540</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mosquitto(MQTT)ubuntu搭建教程</title>
      <link href="/2021/09/03/mosquitto-tutorial/"/>
      <url>/2021/09/03/mosquitto-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Mosquitto是一款实现了 MQTT v3.1 协议的开源消息代理软件，包括了服务器端和客户端，可以跨平台部署，提供轻量级的，支持发布&#x2F;订阅的的消息推送模式，使设备对设备之间的短消息通信简单易用。以下是在Ubuntu环境下，本地搭建MQTT服务器和客户端</p><h1 id="安装mosquitto"><a href="#安装mosquitto" class="headerlink" title="安装mosquitto"></a>安装mosquitto</h1><h2 id="引入mosquitto仓库并更新"><a href="#引入mosquitto仓库并更新" class="headerlink" title="引入mosquitto仓库并更新"></a>引入mosquitto仓库并更新</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="安装mosquitto服务器和客户端"><a href="#安装mosquitto服务器和客户端" class="headerlink" title="安装mosquitto服务器和客户端"></a>安装mosquitto服务器和客户端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mosquitto   #服务端</span><br><span class="line"></span><br><span class="line">sudo apt-get install mosquitto-clients  #客户端（想在windows下测试可以下一个chrome的mqttbox插件）</span><br></pre></td></tr></table></figure><h2 id="开启-x2F-停止mosquitto服务"><a href="#开启-x2F-停止mosquitto服务" class="headerlink" title="开启&#x2F;停止mosquitto服务"></a>开启&#x2F;停止mosquitto服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mosquitto start</span><br><span class="line"></span><br><span class="line">sudo service mosquitto stop</span><br></pre></td></tr></table></figure><h2 id="查看mosquitto服务状态"><a href="#查看mosquitto服务状态" class="headerlink" title="查看mosquitto服务状态"></a>查看mosquitto服务状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mosquitto status </span><br></pre></td></tr></table></figure><p>成功启动如下图：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201343.png"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="ubuntu使用mosquitto-clients"><a href="#ubuntu使用mosquitto-clients" class="headerlink" title="ubuntu使用mosquitto-clients"></a>ubuntu使用mosquitto-clients</h2><h3 id="打开一个终端，订阅主题"><a href="#打开一个终端，订阅主题" class="headerlink" title="打开一个终端，订阅主题"></a>打开一个终端，订阅主题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -h localhost -t &quot;mqtt&quot; -v</span><br></pre></td></tr></table></figure><p>【-h】指定要连接的MQTT服务器<br>【-t】订阅主题，此处为mqtt<br>【-v】打印更多的调试信息  </p><h3 id="打开另一个终端，发布主题"><a href="#打开另一个终端，发布主题" class="headerlink" title="打开另一个终端，发布主题"></a>打开另一个终端，发布主题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mosquitto_pub -h localhost -t &quot;mqtt&quot; -m &quot;Hello MQTT&quot;</span><br></pre></td></tr></table></figure><p>【-h】指定要连接的MQTT服务器<br>【-t】向指定主题推送消息<br>【-m】指定消息内容  </p><h2 id="windows下使用mqttBox"><a href="#windows下使用mqttBox" class="headerlink" title="windows下使用mqttBox"></a>windows下使用mqttBox</h2><ol><li>选择creat MQTT client</li><li>设置ip和端口 选择协议<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201512.png">  </li><li>创建订阅者和发布者开始传输</li></ol><h1 id="配置websockets"><a href="#配置websockets" class="headerlink" title="配置websockets"></a>配置websockets</h1><p>在<code>/etc/mosquitto/conf.d/</code>中新建mosquitto.conf文件并填入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_anonymous true</span><br><span class="line">listener 1883</span><br><span class="line">listener 8883</span><br><span class="line">cafile /etc/mosquitto/certs/callmelp.online_root.crt  # 根证书</span><br><span class="line">certfile /etc/mosquitto/certs/callmelp.online_bundle.crt</span><br><span class="line">keyfile /etc/mosquitto/certs/callmelp.online.key</span><br><span class="line"></span><br><span class="line">listener 8080</span><br><span class="line">protocol websockets</span><br><span class="line">listener 8081</span><br><span class="line">protocol websockets</span><br><span class="line">cafile /etc/mosquitto/certs/callmelp.online_root.crt</span><br><span class="line">certfile /etc/mosquitto/certs/callmelp.online_bundle.crt</span><br><span class="line">keyfile /etc/mosquitto/certs/callmelp.online.key</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>mosquitto -c mosquitto.conf</code>指定配置文件运行，看看报错信息，正常的话应该是这样的：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20221225173920.png" alt="20221225173920"><br>同上使用mqttbox测试一下mqtts、wss是否正常</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_42411153/article/details/95310684">https://blog.csdn.net/weixin_42411153/article/details/95310684</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机通信协议总结</title>
      <link href="/2021/06/23/MCU-tele/"/>
      <url>/2021/06/23/MCU-tele/</url>
      
        <content type="html"><![CDATA[<h1 id="iic通信"><a href="#iic通信" class="headerlink" title="iic通信"></a>iic通信</h1><p>I2C(IIC,Inter－Integrated Circuit), <em><strong>两线式</strong></em> 串行总线,由PHILIPS公司开发用于连接微控制器及其外围设备。<br>它是由 <em><strong>数据线SDA和时钟SCL</strong></em> 构成的串行总线，可发送和接收数据。在CPU与被控IC之间、IC与IC之间进行双向传送，高速IIC总线一般可达400kbps以上。</p><p>IIC是 <em><strong>半双工</strong></em> 通信方式。</p><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><p>iic通信总线需要拉高，空闲时sda和scl都为高电平，结构如下图：<br><img src="https://www.hualigs.cn/image/60d2b49687c0b.jpg" alt="总线结构"></p><h2 id="iic协议状态"><a href="#iic协议状态" class="headerlink" title="iic协议状态"></a>iic协议状态</h2><h3 id="空闲状态"><a href="#空闲状态" class="headerlink" title="空闲状态"></a>空闲状态</h3><p>I2C总线总线的SDA和SCL两条信号线同时处于 <em><strong>高电平</strong></em> 时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。 </p><h3 id="起始信号与停止信号"><a href="#起始信号与停止信号" class="headerlink" title="起始信号与停止信号"></a>起始信号与停止信号</h3><ul><li>起始信号：当SCL为高期间，SDA由高到低的跳变；启动信号是一种电平跳变时序信号，而不是一个电平信号。  </li><li>停止信号：当SCL为高期间，SDA由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。</li></ul><p><img src="https://www.hualigs.cn/image/60d2b58ef2530.jpg">  </p><p>代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     <span class="comment">//sda设置为输出模式</span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;  <span class="comment">//空闲状态，sda和scl都为高</span></span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line"> IIC_SDA=<span class="number">0</span>;    <span class="comment">//START:when CLK is high,DATA change form high to low </span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;    <span class="comment">//钳住iic总线，准备发送或者接收数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();    <span class="comment">//sda输出</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;    <span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line"> delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;   <span class="comment">// 发送iic总线结束信号</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应答信号ACK"><a href="#应答信号ACK" class="headerlink" title="应答信号ACK"></a>应答信号ACK</h3><p>发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为<strong>有效应答位</strong>（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为<strong>非应答位</strong>（NACK），一般表示接收器接收该字节没有成功。 <br><font color=#FF0000>对于反馈有效应答位ACK的要求是，接收器在 <strong>第9个</strong> 时钟脉冲之前的低电平期间将SDA线拉低，并且确保在该时钟的高电平期间为稳定的低电平。</font> 如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号P。<br><img src="https://www.hualigs.cn/image/60d2b635eb0f8.jpg"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待应答信号到来</span></span><br><span class="line"><span class="comment">//返回值：0为接受成功</span></span><br><span class="line"><span class="comment">//        1为接受失败</span></span><br><span class="line">u8 <span class="title function_">IIC_Wait_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">SDA_IN();      <span class="comment">//SDAÉèÖÃÎªÊäÈë  </span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;delay_us(<span class="number">1</span>);   </span><br><span class="line">IIC_SCL=<span class="number">1</span>;delay_us(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span>(READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ucErrTime++;</span><br><span class="line"><span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">&#123;</span><br><span class="line">IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//Ê±ÖÓÊä³ö0    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//产生ack应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();  <span class="comment">//输出模式</span></span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不产生应答    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_NAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p>I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。<br><font color=#ff0000>即：数据在SCL的上升沿到来之前就需准备好。并在在下降沿到来之前必须稳定。</font><br><img src="https://www.hualigs.cn/image/60d2b70984c8c.jpg"></p><h3 id="数据的传送"><a href="#数据的传送" class="headerlink" title="数据的传送"></a>数据的传送</h3><p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。数据位的传输是边沿触发。</p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32时钟系统</title>
      <link href="/2021/06/18/stm32-timer/"/>
      <url>/2021/06/18/stm32-timer/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2019080810214187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="stm32时钟树"></p><ol><li><p>STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。   </p><ul><li>HSI是高速内部时钟，RC振荡器，频率为16MHz，精度不高。可以直接作为系统<br>时钟或者用作PLL时钟输入。       </li><li>HSE是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~26MHz。   </li><li>LSI是低速内部时钟，RC振荡器，频率为32kHz，提供低功耗时钟。主要供独立看门狗和自动唤醒单元使用。    </li><li>LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC    　 </li><li>PLL为锁相环倍频输出。STM32F4有两个PLL:   <ul><li>主PLL(PLL)由HSE或者HSI提供时钟信号，并具有两个不同的输出时钟。  <ul><li>第一个输出PLLP用于生成高速的系统时钟（最高168MHz）    </li><li>第二个输出PLLQ用于生成USB OTG FS的时钟（48MHz），随机数发生器的时钟和SDIO时钟。</li></ul></li><li>专用PLL(PLLI2S)用于生成精确时钟，从而在I2S接口实现高品质音频性能。</li></ul></li></ul></li><li><p>系统时钟SYSCLK可来源于三个时钟源：  </p><ul><li>HSI振荡器时钟  </li><li>HSE振荡器时钟  </li><li>PLL时钟</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32命名规则</title>
      <link href="/2021/06/15/STM32-name/"/>
      <url>/2021/06/15/STM32-name/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327202912.png"></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arduinoIDE导入esp32开发板方法</title>
      <link href="/2021/06/02/esp32-arduinoIDE/"/>
      <url>/2021/06/02/esp32-arduinoIDE/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino环境配置"><a href="#Arduino环境配置" class="headerlink" title="Arduino环境配置"></a>Arduino环境配置</h1><p>首先我们要先去下载Arduino，大家可以去官网下，也可以在Arduino中文社区进行下载，这是中文社区网址<a href="https://www.arduino.cn/">https://www.arduino.cn/</a>。</p><p><img src="https://www.hualigs.cn/image/60b720e41b38a.jpg"></p><h1 id="Arduino添加esp32开发板"><a href="#Arduino添加esp32开发板" class="headerlink" title="Arduino添加esp32开发板"></a>Arduino添加esp32开发板</h1><p>两种方法，arduinoIDE中直接下载，或者使用源码下载：</p><h2 id="方法一（arduino中下载）："><a href="#方法一（arduino中下载）：" class="headerlink" title="方法一（arduino中下载）："></a>方法一（arduino中下载）：</h2><p>文件&gt;首选项&gt;附加开发板管理器网址 中加入Arduino for esp的地址:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://dl.espressif.com/dl/package_esp32_index.json</span><br><span class="line">http://arduino.esp8266.com/stable/package_esp8266com_index.json</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/album/eb3de20abbb0e63b4dcfb9f88918c3232cb3646c.gif"></p><p>完成网址添加后就可以在：工具&gt;开发板&gt;开发板管理器 中搜索并下载esp32开发板数据包（版本选1.0.2）:</p><p><img src="https://i0.hdslb.com/bfs/album/dd41db11f4caa1d9d5b718278ead80863b93ebb6.gif"></p><h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><p><font color=#FF0000>这里的版本最好要选1.0.2!!!!!!!</font>  </p><p>我最开始用的最新1.0.6版本，烧录esp32cam的示例无法正常运行，换成1.0.2就好了</p><p><img src="https://www.hualigs.cn/image/60b7826762a8e.jpg"></p><h2 id="方法二（源码下载）："><a href="#方法二（源码下载）：" class="headerlink" title="方法二（源码下载）："></a>方法二（源码下载）：</h2><p>先去github下载源码：</p><p><a href="https://github.com/espressif/arduino-esp32/">https://github.com/espressif/arduino-esp32/</a></p><p>在arduino的安装目录下找到hardware，新建espressif，再在里面新建esp32，然后把下载的压缩包全都放在目录下面</p><p><img src="https://www.hualigs.cn/image/60b72bbe84d25.jpg"></p><p>打开当前文件夹的tools目录，运行get.exe。然后重启arduino即可。</p><p><img src="https://www.hualigs.cn/image/60b72ca087f3a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp32 </tag>
            
            <tag> arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache2启动报错排查</title>
      <link href="/2021/05/31/apache2-err/"/>
      <url>/2021/05/31/apache2-err/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>阿里云ubuntu版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LSB Version:    core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.1 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure><p>apache:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server version: Apache/2.4.41 (Ubuntu)</span><br><span class="line">Server built:   2020-08-12T19:46:17</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>修改apache的配置文件后，重启apache会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#service apache2 restart</span><br><span class="line"></span><br><span class="line">Job for apache2.service failed because the control process exited with error code.</span><br><span class="line">See &quot;systemctl status apache2.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><p>这个时候不要慌！不要重装！不要放弃！按照提示运行:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status apache2.service</span><br></pre></td></tr></table></figure><h2 id="我这里出现过的错误："><a href="#我这里出现过的错误：" class="headerlink" title="我这里出现过的错误："></a>我这里出现过的错误：</h2><h3 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● apache2.service - The Apache HTTP Server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Mon 2021-05-31 21:00:24 CST; 3s ago</span><br><span class="line">       Docs: https://httpd.apache.org/docs/2.4/</span><br><span class="line">    Process: 1184602 ExecStart=/usr/sbin/apachectl start (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">May 31 21:00:23 iZwz919g91pglb4zkj97ctZ systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184611]: apache2: Syntax error on line 225 of /etc/apache2/apache2.conf: Syntax error on line 34 of /etc/apach&gt;</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184602]: Action &#x27;start&#x27; failed.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184602]: The Apache error log may have more information.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Control process exited, code=exited, status=1/FAILURE</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Failed with result &#x27;exit-code&#x27;.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: Failed to start The Apache HTTP Server.</span><br></pre></td></tr></table></figure><p>看后面log的第二行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache2: Syntax error on line 225 of /etc/apache2/apache2.conf: Syntax error on line 34 of /etc/apach&gt;</span><br></pre></td></tr></table></figure><p>进入配置文件中查看34行的错误，具体情况具体分析</p><h3 id="错误2："><a href="#错误2：" class="headerlink" title="错误2："></a>错误2：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● apache2.service - The Apache HTTP Server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Mon 2021-05-31 21:04:16 CST; 14s ago</span><br><span class="line">       Docs: https://httpd.apache.org/docs/2.4/</span><br><span class="line">    Process: 1184995 ExecStart=/usr/sbin/apachectl start (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: AH00526: Syntax error on line 37 of /etc/apache2/sites-enabled/000-default-ssl.conf:</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: Invalid command &#x27;ProxyRequests&#x27;, perhaps misspelled or defined by a module not included in the server&gt;</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1184995]: Action &#x27;start&#x27; failed.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1184995]: The Apache error log may have more information.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Control process exited, code=exited, status=1/FAILURE</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Failed with result &#x27;exit-code&#x27;.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: Failed to start The Apache HTTP Server.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依旧是看log的第二行,这次加上第三行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: AH00526: Syntax error on line 37 of /etc/apache2/sites-enabled/000-default-ssl.conf:</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: Invalid command &#x27;ProxyRequests&#x27;, perhaps misspelled or defined by a module not included in the server&gt;</span><br></pre></td></tr></table></figure><p>得知ProxyRequests模块未定义，这里是因为我配置了反向代理，然而它找不到模块。只需开启一下代理模块。</p><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a2enmod proxy </span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>OK,成功运行！</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo butterfly视频自适应</title>
      <link href="/2021/05/21/hexo-butterfly-video/"/>
      <url>/2021/05/21/hexo-butterfly-video/</url>
      
        <content type="html"><![CDATA[<p>想在文章中放入视频 结果发现放进去是这样的：<br>(在.md文件里放视频的方法：<a href="https://callmelp.online/2021/05/19/markdown/#%E8%A7%86%E9%A2%91">https://callmelp.online/2021/05/19/markdown/#%E8%A7%86%E9%A2%91</a>)</p><p>youtube：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">&quot;560&quot;</span> <span class="attr">height</span>=<span class="string">&quot;315&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.youtube.com/embed/FuKEpOhiVPg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;YouTube video player&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div>    <iframe width="560" height="315" src="https://www.youtube.com/embed/FuKEpOhiVPg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div><p>bilibili：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=672887323&amp;bvid=BV1sU4y187Lv&amp;cid=333761412&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div>    <iframe src="//player.bilibili.com/player.html?aid=672887323&bvid=BV1sU4y187Lv&cid=333761412&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h1 id="改进的后效果"><a href="#改进的后效果" class="headerlink" title="改进的后效果"></a>改进的后效果</h1><p>原理就是改一下css代码，让div的宽度为100%，然后视频在div里铺开的效果：</p><p>youtube:</p><div class="video">    <iframe width="560" height="315" src="https://www.youtube.com/embed/FuKEpOhiVPg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div><p>bilibili:</p><div class="video">    <iframe src="//player.bilibili.com/player.html?aid=672887323&bvid=BV1sU4y187Lv&cid=333761412&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="新建css"><a href="#新建css" class="headerlink" title="新建css"></a>新建css</h2><p>首先在主题文件夹下<code>source/css</code>里面创建一个<code>video.css</code>的文件，填入：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*视频适配*/</span></span><br><span class="line"><span class="selector-class">.video</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;              <span class="comment">/*高度设置这里无效，设置为0，用padding撑开div*/</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;    <span class="comment">/*68%到80%都可以*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.video</span> <span class="selector-tag">iframe</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主题配置里引入css"><a href="#主题配置里引入css" class="headerlink" title="主题配置里引入css"></a>主题配置里引入css</h2><p>打开主题的配置文件，搜索<code>inject</code>：</p><p><img src="https://www.hualigs.cn/image/60a7ded26c262.jpg"></p><p>我们在head一栏增加下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/video.css&quot;&gt;  </span><br></pre></td></tr></table></figure><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>接下来就可以在.md文件里插入适应屏幕视频了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video&quot;</span>&gt;</span>        //注意这里的div里要设置class</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=18316187&amp;bvid=BV1tW411q7KM&amp;cid=40592634&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK, 这样手机端和PC端都能适配了。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用教程</title>
      <link href="/2021/05/19/markdown/"/>
      <url>/2021/05/19/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown的详细使用方法</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录 "></a><strong>目录</strong> </h2><ul><li><a href="#markdown%E6%A0%87%E9%A2%98">Markdown标题</a><ul><li><a href="#1-%E5%92%8C-%E6%A0%87%E8%AE%B0%E4%B8%80%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">1. &#x3D;和-标记一二级标题</a></li><li><a href="#2-%E4%BD%BF%E7%94%A8--%E5%8F%B7%E6%A0%87%E9%A2%98">2. 使用 # 号标题</a></li></ul></li><li><a href="#markdown%E5%88%86%E5%89%B2%E7%BA%BF">Markdown分割线</a></li><li><a href="#markdown%E5%AD%97%E4%BD%93">Markdown字体</a><ul><li><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">删除线</a></li><li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li><li><a href="#%E8%A1%A8%E6%83%85github%E7%89%88%E6%9C%AC">表情（Github版本）</a></li></ul></li><li><a href="#markdown%E6%AE%B5%E8%90%BD">Markdown段落</a></li><li><a href="#markdown-%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC">MarkDown 目录跳转</a></li><li><a href="#markdown%E5%88%97%E8%A1%A8">Markdown列表</a><ul><li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li><li><a href="#%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97">列表嵌套</a></li><li><a href="#%E5%8C%BA%E5%9D%97">区块</a></li><li><a href="#%E5%A4%8D%E9%80%89%E6%A1%86%E5%88%97%E8%A1%A8github%E7%89%88%E6%9C%AC">复选框列表（Github版本）</a></li></ul></li><li><a href="#markdown%E4%BB%A3%E7%A0%81">Markdown代码</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97">代码区块</a></li></ul></li><li><a href="#markdown%E9%93%BE%E6%8E%A5">Markdown链接</a><ul><li><a href="#%E9%AB%98%E7%BA%A7%E9%93%BE%E6%8E%A5">高级链接</a></li><li><a href="#%E7%94%A8%E6%88%B7%E6%8F%90%E9%86%92">用户@提醒</a></li></ul></li><li><a href="#markdown%E5%9B%BE%E7%89%87%E5%92%8C%E8%A7%86%E9%A2%91">Markdown图片和视频</a><ul><li><a href="#%E8%A7%86%E9%A2%91">视频</a></li></ul></li><li><a href="#markdown-%E8%A1%A8%E6%A0%BC">Markdown 表格</a><ul><li><a href="#%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F">对齐方式</a></li></ul></li><li><a href="#markdown-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">Markdown 高级技巧</a><ul><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84-html-%E5%85%83%E7%B4%A0">支持的 HTML 元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E5%AF%BC%E5%87%BApdf%E5%88%86%E9%A1%B5">导出pdf分页</a></li></ul></li><li><a href="#github-badge">GitHub-badge</a><ul><li><a href="#%E9%9D%99%E6%80%81badge">静态badge</a></li><li><a href="#%E5%8A%A8%E6%80%81%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0badge">动态实时更新badge</a></li></ul></li></ul><h1 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h1><h2 id="1-x3D-和-标记一二级标题"><a href="#1-x3D-和-标记一二级标题" class="headerlink" title="1. &#x3D;和-标记一二级标题"></a>1. &#x3D;和-标记一二级标题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">==============</span><br><span class="line">二级标题</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p>效果(示例添加区块以区分)：  </p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><h2 id="2-使用-号标题"><a href="#2-使用-号标题" class="headerlink" title="2. 使用 # 号标题"></a>2. 使用 # 号标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h1 id="Markdown分割线"><a href="#Markdown分割线" class="headerlink" title="Markdown分割线"></a>Markdown分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><hr></blockquote><blockquote><hr></blockquote><blockquote><hr></blockquote><blockquote><hr></blockquote><blockquote><hr></blockquote><h1 id="Markdown字体"><a href="#Markdown字体" class="headerlink" title="Markdown字体"></a>Markdown字体</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><p>显示效果如下所示：</p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif" width="100%"><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~hello world~~</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><del>hello world</del></p></blockquote><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>通过 HTML 的 &lt;u&gt; 标签来实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;hello world&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><u>hello world</u></p></blockquote><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建脚注格式类似这样 [^tip]。</span><br><span class="line"></span><br><span class="line">[^tip]: 这是一个脚注。</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>创建脚注格式类似这样 <a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8%E3%80%82">^TIP</a>。</p></blockquote><blockquote></blockquote><p>备注：目前Github原生的issue和markdown预览不支持标准md格式的脚注，可以用锚点的特性+上标标签实现相似的功能，参照维基百科的格式，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文章内容&lt;sup id=&quot;a1&quot;&gt;[[1]](#f1)&lt;/sup&gt;</span><br><span class="line"></span><br><span class="line">&lt;span id=&quot;f1&quot;&gt;1. [^](#a1)&lt;/span&gt; 脚注1的说明</span><br></pre></td></tr></table></figure><h2 id="表情（Github版本）"><a href="#表情（Github版本）" class="headerlink" title="表情（Github版本）"></a>表情（Github版本）</h2><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如<code>:smile:</code>可以显示 :smile:</p><p>具体每一个表情的符号码，可以查询GitHub的官方网页<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><h1 id="Markdown段落"><a href="#Markdown段落" class="headerlink" title="Markdown段落"></a>Markdown段落</h1><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" width="100%"><p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg" width="100%"><h1 id="MarkDown-目录跳转"><a href="#MarkDown-目录跳转" class="headerlink" title="MarkDown 目录跳转"></a>MarkDown 目录跳转</h1><p>MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为<code>锚点</code>，跳转的目标称为<code>锚点目标</code>；</p><p>所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个<code>锚点目标</code>和对应的<code>锚点</code>，用户点击<code>锚点</code>便可跳转到对应的<code>锚点目标</code>位置处；</p><p>语法：</p><pre><code>锚点 = [内容](#标题)</code></pre><ul><li>标题 是可选的，可以用单引号 或 双引号；</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于标题#Hello</span><br><span class="line">正确的链接方式是[Hello](#hello)</span><br><span class="line"></span><br><span class="line">对于标题 #Hello World</span><br><span class="line">正确的链接方式为[Hello World](#hello-world)</span><br><span class="line"></span><br><span class="line">注意：()中的字母均为小写，单词之间有间隔用 &#x27;-&#x27; 连接</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Contents  </span><br><span class="line">- [Abstract](#abstract)  </span><br><span class="line">- [Preface](#preface)  </span><br><span class="line">- [Design idea and innovation point](#design-idea-and-innovation-point)  </span><br><span class="line">  - [Background](#background) </span><br><span class="line">  - [Design inspirations](#design-inspirations) </span><br><span class="line">  - [Innovation point](#innovation-point)  </span><br><span class="line">  - [Developmental vision](#developmental-vision) </span><br></pre></td></tr></table></figure><blockquote><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ul><li><a href="#abstract">Abstract</a>  </li><li><a href="#preface">Preface</a>  </li><li><a href="#design-idea-and-innovation-point">Design idea and innovation point</a>  <ul><li><a href="#background">Background</a> </li><li><a href="#design-inspirations">Design inspirations</a> </li><li><a href="#innovation-point">Innovation point</a>  </li><li><a href="#developmental-vision">Developmental vision</a></li></ul></li></ul></blockquote><h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><p>Markdown 支持<u>有序列表</u>和<u>无序列表</u>。</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个<u>空格</u>，然后再填写内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li></ol></blockquote><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>效果（本文效果全部默认添加区块以区分）：</p><blockquote><blockquote><p>hello world</p></blockquote></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt; &gt; 第一层嵌套</span><br><span class="line">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></blockquote><p>备注：区块和列表可互相嵌套</p><h2 id="复选框列表（Github版本）"><a href="#复选框列表（Github版本）" class="headerlink" title="复选框列表（Github版本）"></a>复选框列表（Github版本）</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 需求分析</span><br><span class="line">- [x] 系统设计</span><br><span class="line">- [x] 详细设计</span><br><span class="line">- [ ] 编码</span><br><span class="line">- [ ] 测试</span><br><span class="line">- [ ] 交付</span><br></pre></td></tr></table></figure><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 需求分析</li><li><input checked="" disabled="" type="checkbox"> 系统设计</li><li><input checked="" disabled="" type="checkbox"> 详细设计</li><li><input disabled="" type="checkbox"> 编码</li><li><input disabled="" type="checkbox"> 测试</li><li><input disabled="" type="checkbox"> 交付</li></ul></blockquote><p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p><blockquote><p>Tip:<br>在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p></blockquote><h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><code>printf()</code> 函数</p></blockquote><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键），例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf()</span><br><span class="line">printf()</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><pre><code>printf()printf()</code></pre></blockquote><p>你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定,指定语言后可显示代码高亮）。Github版本：我们使用 <a href="https://github.com/github/linguist">Linguist</a> 来进行语言识别和语法着色。你可以在 <a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">语言 YAML 文件</a> 中查证哪些语言标识符是有效的。：</p><pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>效果：</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><p>链接使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><pre><code>这是一个链接[Baidu](https://www.baidu.com)</code></pre><p>效果：</p><blockquote><p>这是一个链接<a href="https://www.baidu.com/">Baidu</a></p></blockquote><p>直接使用链接地址：</p><pre><code>&lt;https://www.baidu.com&gt;</code></pre><p>效果：</p><blockquote><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p></blockquote><h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line"></span><br><span class="line">这个链接用 2 作为网址变量 [Baidu][2]</span><br><span class="line"></span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: https://www.google.com/</span><br><span class="line">  [2]: https://www.Baidu.com/</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这个链接用 1 作为网址变量 <a href="https://www.google.com/">Google</a></p><p>这个链接用 2 作为网址变量 <a href="https://www.baidu.com/">Baidu</a></p><p>然后在文档的结尾为变量赋值（网址）</p></blockquote><h2 id="用户-提醒"><a href="#用户-提醒" class="headerlink" title="用户@提醒"></a>用户@提醒</h2><p>输入一个@符号，后面跟着一个用户名，会通知那个人来查看评论。 这被称为“@mention” ，因为你提到的是个人。 你也可以@提及组织中的团队。</p><h1 id="Markdown图片和视频"><a href="#Markdown图片和视频" class="headerlink" title="Markdown图片和视频"></a>Markdown图片和视频</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![RUNOOB 图标](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg)</span><br><span class="line"></span><br><span class="line">![RUNOOB 图标](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg &quot;Baidu&quot;)</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&fm=11&gp=0.jpg" alt="Baidu 图标"></p></blockquote><blockquote><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&fm=11&gp=0.jpg" alt="Baidu 图标" title="Baidu"></p></blockquote><p>你也可以像网址那样对图片网址使用变量:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Baidu][1].</span><br><span class="line"></span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">[1]: https://www.baidu.com</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这个链接用 1 作为网址变量 <a href="https://www.google.com/">Baidu</a>.</p><p>然后在文档的结尾为变量赋值（网址）</p></blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</p><p>示例（将图片缩小到50%）：</p><pre><code>&lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><p>效果：</p><blockquote><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&fm=11&gp=0.jpg" width="50%"></blockquote><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>插入视频标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;这里是链接地址&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果： </p><blockquote><div class="bilibili">   <iframe src="//player.bilibili.com/player.html?aid=587752666&bvid=BV1NB4y1c7sN&cid=332373513&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div></blockquote><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></blockquote><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>我们可以设置表格的对齐方式：</p><ul><li><code>-:</code> 设置内容和标题栏居右对齐。</li><li><code>:-</code> 设置内容和标题栏居左对齐。</li><li><code>:-:</code> 设置内容和标题栏居中对齐。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 111 | 21 | 321231 |</span><br><span class="line">| 24241242442 | 3213123 | 4 |</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">111</td><td align="right">21</td><td align="center">321231</td></tr><tr><td align="left">24241242442</td><td align="right">3213123</td><td align="center">4</td></tr></tbody></table></blockquote><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><h2 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>效果：</p><blockquote><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p></blockquote><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**文本加粗** </span><br><span class="line">\*\* 正常显示星号 \*\*</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><strong>文本加粗</strong> </p><p>** 正常显示星号 **</p></blockquote><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h2 id="导出pdf分页"><a href="#导出pdf分页" class="headerlink" title="导出pdf分页"></a>导出pdf分页</h2><p>在markdown文本中需要分页的地方添入：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">STYLE</span>=<span class="string">&quot;page-break-after: always;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Preview窗口不能看到分页的效果， 但是先将markdown文件存为html形式的文件， 然后在输出的pdf文件中的确完成了分页。</p><h1 id="GitHub-badge"><a href="#GitHub-badge" class="headerlink" title="GitHub-badge"></a>GitHub-badge</h1><h2 id="静态badge"><a href="#静态badge" class="headerlink" title="静态badge"></a>静态badge</h2><p>效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20201203142044103.png"></p><p>badge生成网站：</p><p><a href="https://shields.io/">https://shields.io/</a></p><p>进入网站后找到your badge，填入左边标签、右边标签和颜色后可生成：</p><p><img src="https://cdn.sspai.com/editor/u_spencerwoo/15846965978682.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>将生成的链接放在链接图片链接框中即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/LP-markdown-green)</span><br></pre></td></tr></table></figure><p>也可直接修改链接得到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/&#123;左半部分标签&#125;-&#123;右半部分标签&#125;-&#123;右半部分颜色&#125;</span><br></pre></td></tr></table></figure><h2 id="动态实时更新badge"><a href="#动态实时更新badge" class="headerlink" title="动态实时更新badge"></a>动态实时更新badge</h2><p>Shields.io 生成的小牌子完全支持动态数据显示，比如粉丝、关注者数量、RSS 订阅者数量……</p><p>动态更新需要可查看<a href="https://sspai.com/post/59593">此链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析教程</title>
      <link href="/2021/05/18/domain/"/>
      <url>/2021/05/18/domain/</url>
      
        <content type="html"><![CDATA[<h1 id="域名解析教程"><a href="#域名解析教程" class="headerlink" title="域名解析教程"></a>域名解析教程</h1><p>访问一个网站输入域名，比如<code>www.baidu.com</code>就可以访问到百度。但是我们在浏览器输入<code>www.baidu.com</code>之后是怎么访问到百度的网页的呢？百度的网页存在服务器里，但是我们并不知道他的服务器在哪？</p><span id="more"></span><p>其实就是通过DNS解析到的服务器IP，找到服务器IP之后，我们访问<code>www.baidu.com</code>这个访问请求，就会发给百度的服务器，百度的服务器接收到请求，给你返回了对应的内容，然后我们浏览器收到了内容就给你显示了出来，我们就看到了百度的网页。  </p><p>我们要做的域名解析就是要把域名和IP的对应关系告诉DNS，DNS记下来后有访客访问就返回给他了。<br>不同服务商解析域名的方法大差不差，这里使用腾讯云进行解析讲解</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E6%89%80%E9%9C%80%E6%9D%90%E6%96%99">所需材料</a></li><li><a href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">域名解析</a><ul><li><a href="#%E4%B8%BB%E6%9C%BA%E8%AE%B0%E5%BD%95">主机记录</a></li><li><a href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B">记录类型</a></li></ul></li><li><a href="#ssl%E8%AF%81%E4%B9%A6">SSL证书</a><ul><li><a href="#%E8%85%BE%E8%AE%AF%E4%BA%91ssl%E8%AF%81%E4%B9%A6">腾讯云SSL证书</a></li></ul></li></ul><h2 id="所需材料"><a href="#所需材料" class="headerlink" title="所需材料"></a>所需材料</h2><ol><li>已实名和备案的域名(我们解析的ip地址在国内，所以域名必须通过备案)</li><li>一台公网ip服务器</li></ol><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>进如腾讯云的<a href="https://console.cloud.tencent.com/domain">域名控制台</a>,点击域名后面的解析。</p><p><img src="https://www.hualigs.cn/image/60a34aa10190f.jpg"></p><p>进入dnspod（腾讯云的是这个，不同服务商的dns解析不一样）</p><p><img src="https://www.hualigs.cn/image/60a34b9e4b139.jpg"></p><p>接下来讲一下解析记录里参数都是干啥的</p><h3 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h3><p>主机记录相当于域名的前缀，比如 www</p><table><thead><tr><th>记录</th><th>解释</th></tr></thead><tbody><tr><td>www</td><td>常见主机记录，将域名解析为 <a href="http://www.callmelp.online/">www.callmelp.online</a></td></tr><tr><td>@</td><td>直接解析主域名 callmelp.online</td></tr><tr><td>mail</td><td>将域名解析为 mail.callmelp.online，通常用于邮件服务</td></tr><tr><td>*</td><td>泛解析，匹配其他所有域名 *.callmelp.online</td></tr></tbody></table><p>这里可以写任何值，比如你用baidu.com这个域名，记录写baidu，你就可以用baidu.baidu.com访问某个服务器</p><h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><table><thead><tr><th>记录类型</th><th>使用目的</th></tr></thead><tbody><tr><td>A 记录</td><td>将域名指向一个 IP 地址（外网地址）。</td></tr><tr><td>CNAME 记录</td><td>将域名指向另一个域名，再由另一个域名提供 IP 地址（外网地址）。</td></tr><tr><td>MX 记录</td><td>设置邮箱，让邮箱能收到邮件。</td></tr><tr><td>NS 记录</td><td>将子域名交给其他 DNS 服务商解析。</td></tr><tr><td>AAAA 记录</td><td>将域名指向一个 IPv6 地址。</td></tr><tr><td>SRV 记录</td><td>用来标识某台服务器使用了某个服务，常见于微软系统的目录管理。</td></tr><tr><td>TXT 记录</td><td>对域名进行标识和说明，绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件）。</td></tr><tr><td>隐、显性 URL 记录</td><td>将一个域名指向另外一个已经存在的站点。</td></tr></tbody></table><p>我们使用A将域名解析到ip地址</p><hr><p>例如我们要将abc前缀的域名解析到0.0.0.0这个ip：</p><p><img src="https://www.hualigs.cn/image/60a34f6d642dd.jpg"></p><p>确认即可。</p><h2 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h2><p>为了用户的安全，https使用加密传输。在握手过程中，网站会向浏览器发送SSL证书，SSL证书和我们日常用的身份证类似，是一个支持HTTPS网站的身份证明，SSL证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。在这一部分我将对SSL证书的验证过程以及个人用户在访问HTTPS网站时，对SSL证书的使用需要注意哪些安全方面的问题进行描述。</p><h3 id="腾讯云SSL证书"><a href="#腾讯云SSL证书" class="headerlink" title="腾讯云SSL证书"></a>腾讯云SSL证书</h3><p>进入<a href="https://console.cloud.tencent.com/ssl">腾讯云SSL证书管理</a></p><p><img src="https://www.hualigs.cn/image/60a350ffba75c.jpg"></p><p>点击下载即可。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Octave简明教程</title>
      <link href="/2021/05/15/Octave-tutorial/"/>
      <url>/2021/05/15/Octave-tutorial/</url>
      
        <content type="html"><![CDATA[<p>吴恩达的机器学习课程的作业可以使用Matlab或者octave，这里记录一下octave的基本操作。</p><span id="more"></span><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><a href="#%E7%AC%A6%E5%8F%B7">符号</a></li><li><a href="#%E7%9F%A9%E9%98%B5">矩阵</a><ul><li><a href="#%E7%9F%A9%E9%98%B5%E5%88%9D%E5%A7%8B%E5%8C%96">矩阵初始化</a></li><li><a href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E5%88%9D%E5%A7%8B%E5%8C%96">特殊矩阵初始化</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%B4%A2%E5%BC%95">矩阵索引</a></li></ul></li><li><a href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E5%8C%96">矩阵变化</a><ul><li><a href="#%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC">重新赋值</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%96%B0%E8%A1%8C%E5%88%97">添加到新行&#x2F;列</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E5%8C%96">矩阵向量化</a></li></ul></li><li><a href="#%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97">矩阵计算</a><ul><li><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%8A%A0%E5%87%8F">矩阵相加减</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%E9%99%A4">矩阵相乘除</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97">矩阵运算</a></li></ul></li><li><a href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0">内建函数</a></li><li><a href="#%E7%94%BB%E5%9B%BE">画图</a></li><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li></ul><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><table><thead><tr><th align="center">符号</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">%</td><td align="center">注释</td></tr><tr><td align="center">~&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">;</td><td align="center">结束符</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td></tr><tr><td align="center">‘</td><td align="center">转置</td></tr></tbody></table><p>&gt; , &lt; , &#x3D;这些符号可以应用到矩阵中，可以将矩阵中的每一个元素和符号后的数字进行比较，最终判断成立返回1， 判断错误返回0.</p><p>示例：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">2</span></span><br><span class="line">&gt;&gt; <span class="number">1</span>*<span class="number">8</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">8</span></span><br><span class="line">&gt;&gt; a = <span class="number">3</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">&gt;&gt; a~=<span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt; a~=<span class="number">3</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0</span></span><br><span class="line">&gt;&gt; a = [<span class="number">11</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">1</span> <span class="number">21</span> <span class="number">3</span> ; <span class="number">1</span> <span class="number">2</span> <span class="number">32</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">11</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span>   <span class="number">32</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a &gt;<span class="number">10</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&gt;&gt; a == <span class="number">10</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a == <span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">&gt;&gt; a&#x27;</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">11</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>   <span class="number">21</span>    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>    <span class="number">3</span>   <span class="number">32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵初始化"><a href="#矩阵初始化" class="headerlink" title="矩阵初始化"></a>矩阵初始化</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>注：<code>;</code>代表的是换行，每一行中可以拿,隔开也可以不用，直接空开就可以。</p><h4 id="特殊矩阵初始化"><a href="#特殊矩阵初始化" class="headerlink" title="特殊矩阵初始化"></a>特殊矩阵初始化</h4><p>单位阵：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">eye</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><p>全一阵：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">% 前一个3为行数，后一个3为列数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><p>全零阵：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随机矩阵：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.1583</span>   <span class="number">0.6459</span>   <span class="number">0.4255</span></span><br><span class="line">   <span class="number">0.4938</span>   <span class="number">0.3079</span>   <span class="number">0.2308</span></span><br><span class="line">   <span class="number">0.1299</span>   <span class="number">0.7594</span>   <span class="number">0.4041</span></span><br></pre></td></tr></table></figure><p>魔法矩阵：每行，每列，对角的和都相等的矩阵</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">magic</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">8</span>   <span class="number">1</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">5</span>   <span class="number">7</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">9</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="矩阵索引"><a href="#矩阵索引" class="headerlink" title="矩阵索引"></a>矩阵索引</h4><p><code>:</code>冒号表示从…到…，单独的冒号表示所有</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">︋&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">&gt;&gt; a(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment">%第一行第一列</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt; a(<span class="number">2</span>, <span class="number">2</span>)   <span class="comment">%第二行第二列</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">5</span></span><br><span class="line">&gt;&gt; a(<span class="number">1</span>:<span class="number">2</span>, <span class="number">1</span>:<span class="number">2</span>)   <span class="comment">%1到2行，1到2列</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a(:, <span class="number">1</span>:<span class="number">2</span>)     <span class="comment">%所有行，1到2列</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="矩阵变化"><a href="#矩阵变化" class="headerlink" title="矩阵变化"></a>矩阵变化</h3><p>以下示例均使用<code>a  = [1 2 3; 4 5 6; 7 8 9]</code></p><h4 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a(<span class="number">1</span>,:) = [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>] <span class="comment">%将第一行改为 7 8 9 </span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="添加到新行-x2F-列"><a href="#添加到新行-x2F-列" class="headerlink" title="添加到新行&#x2F;列"></a>添加到新行&#x2F;列</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a = [a, [<span class="number">10</span>; <span class="number">11</span>; <span class="number">12</span>]] <span class="comment">%添加列</span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span>   <span class="number">11</span></span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">&gt;&gt; a = [a ;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]  <span class="comment">%添加行</span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="矩阵向量化"><a href="#矩阵向量化" class="headerlink" title="矩阵向量化"></a>矩阵向量化</h4><p>按照列的顺序排布：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">&gt;&gt; a(:)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   <span class="number">7</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">5</span></span><br><span class="line">   <span class="number">8</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>如果想按行排布，可以使用转置：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a&#x27;(:)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   <span class="number">5</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span></span><br><span class="line">   <span class="number">8</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><h4 id="矩阵相加减"><a href="#矩阵相加减" class="headerlink" title="矩阵相加减"></a>矩阵相加减</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a+<span class="number">1</span>  </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line">&gt;&gt; a+a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span></span><br><span class="line">    <span class="number">8</span>   <span class="number">10</span>   <span class="number">12</span></span><br><span class="line">   <span class="number">14</span>   <span class="number">16</span>   <span class="number">18</span></span><br><span class="line">&gt;&gt; a-a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a<span class="number">-1</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="矩阵相乘除"><a href="#矩阵相乘除" class="headerlink" title="矩阵相乘除"></a>矩阵相乘除</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a *a   <span class="comment">%叉乘：线性代数中的叉乘</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">30</span>    <span class="number">36</span>    <span class="number">42</span></span><br><span class="line">    <span class="number">66</span>    <span class="number">81</span>    <span class="number">96</span></span><br><span class="line">   <span class="number">102</span>   <span class="number">126</span>   <span class="number">150</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a.*a    <span class="comment">%点乘：对应位置相乘</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">   <span class="number">16</span>   <span class="number">25</span>   <span class="number">36</span></span><br><span class="line">   <span class="number">49</span>   <span class="number">64</span>   <span class="number">81</span></span><br><span class="line">&gt;&gt; a./<span class="number">2</span>    <span class="comment">%点除：同上</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.5000</span>   <span class="number">1.0000</span>   <span class="number">1.5000</span></span><br><span class="line">   <span class="number">2.0000</span>   <span class="number">2.5000</span>   <span class="number">3.0000</span></span><br><span class="line">   <span class="number">3.5000</span>   <span class="number">4.0000</span>   <span class="number">4.5000</span></span><br></pre></td></tr></table></figure><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a.^<span class="number">2</span>    <span class="comment">%幂运算</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">   <span class="number">16</span>   <span class="number">25</span>   <span class="number">36</span></span><br><span class="line">   <span class="number">49</span>   <span class="number">64</span>   <span class="number">81</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">exp</span>(a)    <span class="comment">%指数运算：每个数都求以e为底的指数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">2.7183e+00</span>   <span class="number">7.3891e+00</span>   <span class="number">2.0086e+01</span></span><br><span class="line">   <span class="number">5.4598e+01</span>   <span class="number">1.4841e+02</span>   <span class="number">4.0343e+02</span></span><br><span class="line">   <span class="number">1.0966e+03</span>   <span class="number">2.9810e+03</span>   <span class="number">8.1031e+03</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log</span>(a)    <span class="comment">%对数运算：以e为底</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">0.6931</span>   <span class="number">1.0986</span></span><br><span class="line">   <span class="number">1.3863</span>   <span class="number">1.6094</span>   <span class="number">1.7918</span></span><br><span class="line">   <span class="number">1.9459</span>   <span class="number">2.0794</span>   <span class="number">2.1972</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log2</span>(a)    <span class="comment">%对数运算：以2为底(以什么为底就log什么)</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span>   <span class="number">1.5850</span></span><br><span class="line">   <span class="number">2.0000</span>   <span class="number">2.3219</span>   <span class="number">2.5850</span></span><br><span class="line">   <span class="number">2.8074</span>   <span class="number">3.0000</span>   <span class="number">3.1699</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log10</span>(a)    <span class="comment">%对数运算：以10为底</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">0.3010</span>   <span class="number">0.4771</span></span><br><span class="line">   <span class="number">0.6021</span>   <span class="number">0.6990</span>   <span class="number">0.7782</span></span><br><span class="line">   <span class="number">0.8451</span>   <span class="number">0.9031</span>   <span class="number">0.9542</span></span><br></pre></td></tr></table></figure><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><ol><li><p>length()：返回的是长度，有可能是行的个数有，可能是列的个数。这取决于那个时候更大</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">length</span>(a)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">3</span></span><br><span class="line">&gt;&gt; <span class="built_in">length</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p>max():对于向量来说会返回其中最大的一个数字,对矩阵来说会返回一个向量，向量的每一列对应原来矩阵每一列的最大值</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">max</span>([ <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> ])</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">9</span></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(a, [], <span class="number">2</span>)   <span class="comment">%第三个参数表示按行找最大值（若为1则是按列找，默认为1）</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>floor():向下取整<br>ceil():向上取整</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">floor</span>(<span class="number">10.12</span>)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">10</span></span><br><span class="line">&gt;&gt; <span class="built_in">ceil</span>(<span class="number">10.12</span>)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">11</span></span><br></pre></td></tr></table></figure></li><li><p>sum():按行&#x2F;列相加</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">︋&gt;&gt; sum(a,<span class="number">1</span>)   <span class="comment">%第二个参数为1时，按列加（默认为1）</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">12</span>   <span class="number">15</span>   <span class="number">18</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a,<span class="number">2</span>)    <span class="comment">%第二个参数为2时，按行加</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">   <span class="number">15</span></span><br><span class="line">   <span class="number">24</span></span><br></pre></td></tr></table></figure></li><li><p>flipud():将矩阵上下颠倒</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">flipud</span>(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>rank():求矩阵的秩</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rank(a)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>rref():将矩阵化为行最简</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rref(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span>        <span class="number">0</span>  <span class="number">-1.0000</span></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span>   <span class="number">2.0000</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>pinv():求矩阵的逆矩阵</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">3</span>,<span class="number">4</span>;<span class="number">2</span>,<span class="number">16</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">    <span class="number">2</span>   <span class="number">16</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(a)*a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span>  <span class="number">-0.0000</span></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.400000</span>  <span class="number">-0.100000</span></span><br><span class="line">  <span class="number">-0.050000</span>   <span class="number">0.075000</span></span><br></pre></td></tr></table></figure></li><li><p>reshape():将向量矩阵化</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a = <span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);       <span class="comment">%初始化一个10维向量</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">reshape</span>(a, <span class="number">5</span>, <span class="number">2</span>)      <span class="comment">%第二个参数是矩阵的行数， 第三个是矩阵的列数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x = <span class="number">-1</span>:<span class="number">0.1</span>:<span class="number">1</span>;</span><br><span class="line">&gt;&gt; y = x.^<span class="number">2</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x, y)</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/609f8e0201cd9.jpg"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on <span class="comment">%若要保留上一次的结果就hold on</span></span><br><span class="line">y2 = -x .^ <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">plot</span>(x, y2, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3062143-b685e1adc68a9cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1156/format/webp"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 加标签</span></span><br><span class="line">xlabel(<span class="string">&quot;x value&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;y value&quot;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x^2&quot;</span>, <span class="string">&quot;-x^2+1&quot;</span>); <span class="comment">% 对应图中的颜色线条注释</span></span><br><span class="line">title(<span class="string">&quot;first plot&quot;</span>);</span><br><span class="line">cd Desktop; print -dpng <span class="string">&quot;firstPlot.png&quot;</span> <span class="comment">%会保存到桌面上</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3062143-6504fece7838e5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>for循环：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>while循环：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">0</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;HI&quot;</span>);</span><br><span class="line">  a -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>if&#x2F;else:</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> a &gt; <span class="number">1</span></span><br><span class="line">&gt;   <span class="built_in">disp</span>(<span class="string">&quot;a is bigger than 1&quot;</span>);</span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt;   <span class="built_in">disp</span>(<span class="string">&quot;a is smaller than 1&quot;</span>);</span><br><span class="line">&gt; endif;</span><br><span class="line"></span><br><span class="line">&gt;&gt; a is smaller than <span class="number">1</span></span><br></pre></td></tr></table></figure><p>创建函数：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">val</span> = <span class="title">func</span><span class="params">(x, y)</span>    %<span class="title">x</span>,<span class="title">y</span>是函数传入的参数，<span class="title">val</span>是返回值</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Octave </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js web服务器搭建</title>
      <link href="/2021/05/11/nodejs-webserver/"/>
      <url>/2021/05/11/nodejs-webserver/</url>
      
        <content type="html"><![CDATA[<p>使用nodejs搭建文件目录结构的web服务器,以及node forever模块的使用</p><span id="more"></span><p>nodejs的安装和使用以及npm的使用方法自己查</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA">web服务器搭建</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E5%AF%B9%E5%BA%94%E5%BA%93">安装对应库</a></li><li><a href="#%E8%8E%B7%E5%BE%97https%E7%9A%84ssl%E8%AF%81%E4%B9%A6">获得https的ssl证书</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">文件目录</a></li><li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li><li><a href="#servejs%E4%BB%A3%E7%A0%81web%E6%A0%B9%E7%9B%AE%E5%BD%95">serve.js代码（web根目录）</a></li></ul></li><li><a href="#forever%E8%AF%B4%E6%98%8E">forever说明</a><ul><li><a href="#forever%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">forever安装和使用</a><ul><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li></ul></li></ul></li></ul><h2 id="web服务器搭建"><a href="#web服务器搭建" class="headerlink" title="web服务器搭建"></a>web服务器搭建</h2><h3 id="安装对应库"><a href="#安装对应库" class="headerlink" title="安装对应库"></a>安装对应库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express</span><br><span class="line">npm install serve-index</span><br></pre></td></tr></table></figure><h3 id="获得https的ssl证书"><a href="#获得https的ssl证书" class="headerlink" title="获得https的ssl证书"></a>获得https的ssl证书</h3><p>购买域后进行实名认证，通过后即可下载</p><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><img src="https://www.hualigs.cn/image/609a0dde34285.jpg" width="50%"><p>cert:存放ssl证书<br>node_modules:nodejs的库<br>public:web页面的目录<br>server.js:web服务器代码               </p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo forever start server.js</span><br></pre></td></tr></table></figure><p>forever可以不占用终端在后台运行</p><p>停止：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo forever stop server.js</span><br></pre></td></tr></table></figure><p>说明：forever需要用npm下载</p><hr><p>如果想临时使用或者查看log，可以使用node运行： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo node server.js</span><br></pre></td></tr></table></figure><h3 id="serve-js代码（web根目录）"><a href="#serve-js代码（web根目录）" class="headerlink" title="serve.js代码（web根目录）"></a>serve.js代码（web根目录）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serveIndex = <span class="built_in">require</span>(<span class="string">&#x27;serve-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序不能换</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serveIndex</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">key  : fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cert/callmelp.online.key&#x27;</span>),</span><br><span class="line">cert : fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cert/callmelp.online.pem&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https_server = https.<span class="title function_">createServer</span>(options, app);</span><br><span class="line">https_server.<span class="title function_">listen</span>(<span class="number">443</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http_server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line">http_server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="forever说明"><a href="#forever说明" class="headerlink" title="forever说明"></a>forever说明</h2><p><a href="https://github.com/foreverjs/forever">forever Github地址</a></p><p>forever可以看做是一个nodejs的守护进程，能够启动，停止，重启我们的app应用。</p><p>forever的用途就是帮我们更好的管理我们node App服务，本质上就是在forever进程之下，创建一个node app的子进程。使用类似于<code>service apache2 start</code>这样的命令即可操作node后台运行。</p><p>更好的一点就是每次更改文件，它都可以帮你自动重启服务而不需要手动重启（需要配置持续监听-w）</p><h3 id="forever安装和使用"><a href="#forever安装和使用" class="headerlink" title="forever安装和使用"></a>forever安装和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install forever -g  //-g 全局安装</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>启动相关<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 简单的启动</span><br><span class="line">forever start app.js</span><br><span class="line"></span><br><span class="line">// 2. 指定forever信息输出文件，当然，默认它会放到~/.forever/forever.log</span><br><span class="line">forever start -l forever.log app.js</span><br><span class="line"></span><br><span class="line">// 3. 指定app.js中的日志信息和错误日志输出文件，</span><br><span class="line">// -o 就是console.log输出的信息，-e 就是console.error输出的信息</span><br><span class="line">forever start -o out.log -e err.log app.js</span><br><span class="line"></span><br><span class="line">// 4. 追加日志，forever默认是不能覆盖上次的启动日志，</span><br><span class="line">// 所以如果第二次启动不加-a，则会不让运行</span><br><span class="line">forever start -l forever.log -a app.js</span><br><span class="line"></span><br><span class="line">// 5. 监听当前文件夹下的所有文件改动，并重启服务</span><br><span class="line">forever start -w app.js</span><br><span class="line"></span><br><span class="line">// 6. 显示所有运行的服务</span><br><span class="line">forever list</span><br></pre></td></tr></table></figure></li><li>停止<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 停止所有运行的node App</span><br><span class="line">forever stopall</span><br><span class="line"></span><br><span class="line">// 2. 停止其中一个node App</span><br><span class="line">forever stop app.js</span><br><span class="line">// 当然还可以这样</span><br><span class="line">// forever list 找到对应的id，然后：</span><br><span class="line">forever stop [id]</span><br></pre></td></tr></table></figure></li><li>重启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 启动所有</span><br><span class="line">forever restartall</span><br><span class="line">// 2. 重启其中一个node App</span><br><span class="line">forever restart app.js</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用教程</title>
      <link href="/2021/05/11/hexo-tutorial/"/>
      <url>/2021/05/11/hexo-tutorial/</url>
      
        <content type="html"><![CDATA[<p>记录一下每次使用hexo写博文会使用的操作</p><span id="more"></span><h2 id="写新博客"><a href="#写新博客" class="headerlink" title="写新博客"></a>写新博客</h2><p>打开git bash或者cmd，进入hexo存放的工作目录<br><img src="https://www.hualigs.cn/image/609a12d37a26b.jpg"></p><p>gitbash：<br><img src="https://www.hualigs.cn/image/609a12d33a53a.jpg">  </p><p>终端执行：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure><p>(xxx为文件名)<br><img src="https://www.hualigs.cn/image/609a1433e768d.jpg"><br>进如上图显示的目录，即可看到新创建的md文件。</p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>gitbash或者cmd在hexo的工作目录下输入：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>（-g参数一定要加 先生成再上传）</p><p>我这里是配置好了github的上传操作，如果没有配置过可以看我的<a href="https://callmelp.github.io/2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/">上一篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客总结</title>
      <link href="/2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#github%E7%94%9F%E6%88%90%E4%BB%93%E5%BA%93">github生成仓库</a></li><li><a href="#%E9%85%8D%E7%BD%AEssh%E7%95%A5">配置ssh（略）</a></li><li><a href="#hexo%E5%AE%89%E8%A3%85">hexo安装</a></li><li><a href="#%E4%B8%8A%E4%BC%A0github">上传github</a></li><li><a href="#%E5%B8%B8%E7%94%A8hexo%E5%91%BD%E4%BB%A4">常用hexo命令</a></li><li><a href="#%E5%86%99%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7">写博客工具</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8D%9A%E6%96%87%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9">如何让博文列表不显示全部内容</a></li><li><a href="#%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9Agithub%E7%AB%99%E7%82%B9">用自己的域名绑定github站点</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h2 id="github生成仓库"><a href="#github生成仓库" class="headerlink" title="github生成仓库"></a>github生成仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="配置ssh（略）"><a href="#配置ssh（略）" class="headerlink" title="配置ssh（略）"></a>配置ssh（略）</h2><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>用git bash直接安装，代码：</p><pre><code>$ npm install -g hexo</code></pre><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动服务</span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些public里的文件将来都是要提交到github去的。</p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p><p><a href="http://blog.liuxianan.com/windows-port-bind.html">http://blog.liuxianan.com/windows-port-bind.html</a></p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan/liuxianan.github.io.git(不是https那个)</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>此时直接执行hexo d的话一般会报如下错误：</p><pre><code>Deployer not found: github 或者 Deployer not found: git</code></pre><p>原因是还需要安装一个插件：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>其它命令不确定，部署这个命令一定要用<code>git bash</code>，否则会提示<code>Permission denied (publickey)</code>.</p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会提交。</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>常见命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>##写博客</p><p>定位到我们的hexo根目录，执行命令：</p><pre><code>hexo new &#39;my-first-blog&#39;</code></pre><p>hexo会帮我们在_posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了（想删除博文是只用删掉对应生成的md文件就行了）。</p><h2 id="写博客工具"><a href="#写博客工具" class="headerlink" title="写博客工具"></a>写博客工具</h2><p>具体用什么还是看个人喜好，我用vscode非常方便。只需要下载两个插件：</p><pre><code>Markdown All in OneMarkdown Preview Github Styling</code></pre><p>在vscode里写完可以直接看到md生成的效果。</p><h2 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h2><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p><pre><code>使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等；</code></pre><h2 id="用自己的域名绑定github站点"><a href="#用自己的域名绑定github站点" class="headerlink" title="用自己的域名绑定github站点"></a>用自己的域名绑定github站点</h2><p>进入github项目目录，点击<code>Add file</code>-&gt;<code>creat new file</code></p><p><img src="https://www.hualigs.cn/image/60a776cc2d319.jpg"></p><p>文件名写CNAME,文件里写上你的域名（不加前缀www）</p><p><img src="https://www.hualigs.cn/image/60a7773274579.jpg"></p><p>进入你的域名解析页面，添加CNAME记录</p><p><img src="https://www.hualigs.cn/image/60a778873c35d.jpg"></p><p>OK!现在就可以用你自己的域名访问你的博客啦</p><p><img src="https://www.hualigs.cn/image/60a778ee3739a.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></p><p><a href="https://hexo.io/zh-cn/docs/">hexo官方中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
